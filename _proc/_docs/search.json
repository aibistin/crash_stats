[
  {
    "objectID": "core.html",
    "href": "core.html",
    "title": "core",
    "section": "",
    "text": "source\n\nfoo\n\n foo ()"
  },
  {
    "objectID": "crash_time_period_stats.html",
    "href": "crash_time_period_stats.html",
    "title": "NYC Collision Data Analysis",
    "section": "",
    "text": "What month of the year? …what day of the week? …what time of day?\nHas the most human casualties on New York’s streets?\n\nI’ve spent considerable time walking, biking, driving and taking public transport in this busy city. Just like many New Yorkers, I’ve also had numerous close calls with vehicles while crossing wide streets, where traffic turns onto your crossing lane as you try to make it to the other side in one piece.\nUsing the information provided by NYC Open Data, I wanted to find out when most human casualty causing collisions occur, and how I could best present that information.\n\n\n\n\n\n\nTip\n\n\n\nYou can skip the explanations and go straight to the results.\nor,\nYou can read on and see how I came up with these numbers.\n\n\n\n\n\n\n\n\nTechnology Used\n\n\n\n\nPython\nJupyter Notebook\npandas\nMatplotlib\nSeaborn\nnbdev\n\n\n\n\n\n\n\nCode - Import All Required Python Modules\nimport datetime\nfrom pathlib import Path\n\nimport matplotlib.pyplot as plt\n\n# Import All Required Python Modules\nimport numpy as np\nimport pandas as pd\nimport seaborn as sns\n\n\n\n\nCode - Data Formatting Functions\n# Data Formatting Functions\n\n\ndef empty_to_zero(val):\n    \"\"\"Converts empty values to 0\"\"\"\n    val = val.strip(\"\\s+\")\n    return val if len(val) else 0\n\n\ndef convert_to_numeric(df, column_list):\n    \"\"\"Given a list of DataFrame columns, it converts the empty values to zero\"\"\"\n    df[column_list] = df[column_list].apply(pd.to_numeric, errors=\"coerce\")\n\n\n\n\nCode - Set Up Some Global Variables\n# Set Up Some Global Variables\n\n# I'm omitting longitude, latitude, the vehicle types as well as crash contributing factors.\ncols_requested = [\n    \"COLLISION_ID\",\n    \"CRASH DATE\",\n    \"CRASH TIME\",\n    \"BOROUGH\",\n    \"ZIP CODE\",\n    \"LOCATION\",\n    \"ON STREET NAME\",\n    \"CROSS STREET NAME\",\n    \"OFF STREET NAME\",\n    \"NUMBER OF PERSONS INJURED\",\n    \"NUMBER OF PERSONS KILLED\",\n    \"NUMBER OF PEDESTRIANS INJURED\",\n    \"NUMBER OF PEDESTRIANS KILLED\",\n    \"NUMBER OF CYCLIST INJURED\",\n    \"NUMBER OF CYCLIST KILLED\",\n    \"NUMBER OF MOTORIST INJURED\",\n    \"NUMBER OF MOTORIST KILLED\",\n]\n\n# To ensure that the colums are of the expected data type\ncrash_dtypes = {\n    \"CRASH DATE\": str,\n    \"CRASH TIME\": str,\n    \"BOROUGH\": str,\n    \"ZIP CODE\": str,\n    \"LOCATION\": str,\n    \"ON STREET NAME\": str,\n    \"CROSS STREET NAME\": str,\n    \"OFF STREET NAME\": str,\n}\n\n# Rename some colums to ones that I believe are shorter and/or more meaningful\ncols_rename = {\n    \"CRASH DATE\": \"DATE\",\n    \"CRASH TIME\": \"TIME\",\n    \"ZIP CODE\": \"ZIP_CODE\",\n    \"ON STREET NAME\": \"ON_STREET_NAME\",\n    \"CROSS STREET NAME\": \"CROSS_STREET_NAME\",\n    \"OFF STREET NAME\": \"OFF_STREET_NAME\",\n    \"NUMBER OF PERSONS INJURED\": \"NUM_PERSONS_INJURED\",\n    \"NUMBER OF PERSONS KILLED\": \"NUM_PERSONS_KILLED\",\n    \"NUMBER OF PEDESTRIANS INJURED\": \"NUM_PEDESTRIANS_INJURED\",\n    \"NUMBER OF PEDESTRIANS KILLED\": \"NUM_PEDESTRIANS_KILLED\",\n    \"NUMBER OF CYCLIST INJURED\": \"NUM_CYCLISTS_INJURED\",\n    \"NUMBER OF CYCLIST KILLED\": \"NUM_CYCLISTS_KILLED\",\n    \"NUMBER OF MOTORIST INJURED\": \"NUM_MOTORISTS_INJURED\",\n    \"NUMBER OF MOTORIST KILLED\": \"NUM_MOTORISTS_KILLED\",\n}\n\n# Columns that contain numeric values\nnumeric_cols = [\n    \"NUM_PERSONS_INJURED\",\n    \"NUM_PERSONS_KILLED\",\n    \"NUM_PEDESTRIANS_INJURED\",\n    \"NUM_PEDESTRIANS_KILLED\",\n    \"NUM_CYCLISTS_INJURED\",\n    \"NUM_CYCLISTS_KILLED\",\n    \"NUM_MOTORISTS_INJURED\",\n    \"NUM_MOTORISTS_KILLED\",\n]\n\n# These ordered lists are useful for plotting charts\nday_names_order = [\n    \"Monday\",\n    \"Tuesday\",\n    \"Wednesday\",\n    \"Thursday\",\n    \"Friday\",\n    \"Saturday\",\n    \"Sunday\",\n]\nday_abbr_order = [d[0:3] for d in day_names_order]\nmonth_names_order = [\n    \"January\",\n    \"February\",\n    \"March\",\n    \"April\",\n    \"May\",\n    \"June\",\n    \"July\",\n    \"August\",\n    \"September\",\n    \"October\",\n    \"November\",\n    \"December\",\n]\nmonth_abbr_order = [m[0:3] for m in month_names_order]\n\n# The following DataFrame columns that will have their empty values converted to zero using the\n# 'empty_to_zero' function\nconvert_cols = {\n    \"NUMBER OF PERSONS INJURED\": empty_to_zero,\n    \"NUMBER OF PERSONS KILLED\": empty_to_zero,\n    \"NUMBER OF PEDESTRIANS INJURED\": empty_to_zero,\n    \"NUMBER OF PEDESTRIANS KILLED\": empty_to_zero,\n    \"NUMBER OF CYCLIST INJURED\": empty_to_zero,\n    \"NUMBER OF CYCLIST KILLED\": empty_to_zero,\n    \"NUMBER OF MOTORIST INJURED\": empty_to_zero,\n    \"NUMBER OF MOTORIST KILLED\": empty_to_zero,\n}\n\n# These are the 4 categories supplied by the NYPD\nvictim_categories = [\"person\", \"cyclist\", \"motorist\", \"pedestrian\"]\n# 'person' status should be a combination of the other three categories\n# TODO I need to verify the relationship between 'person' and the other three categories\n\n# These are the Matplotlib Tableau colors\nbar_colors = [\n    \"tab:blue\",\n    \"tab:orange\",\n    \"tab:green\",\n    \"tab:red\",\n    \"tab:purple\",\n    \"tab:brown\",\n    \"tab:pink\",\n    \"tab:gray\",\n    \"tab:olive\",\n    \"tab:cyan\",\n]\n\nbase_colors = [\"b\", \"g\", \"r\", \"c\", \"m\", \"y\", \"k\", \"w\"]\n\n# Chart Colors\ncolor = \"k\"\nplt.rcParams[\"text.color\"] = color\nplt.rcParams[\"axes.labelcolor\"] = color\nplt.rcParams[\"xtick.color\"] = \"b\"\nplt.rcParams[\"ytick.color\"] = \"b\"\n\n\n\n\n\n\n\n\n\nCode - Creating the ‘crash’ DataFrame from the NYPD CSV file.\ncollision_filename = \"Motor_Vehicle_Collisions_Aug15_2023.csv\"\n\n# Using the Pandas 'read_csv' function\ncrash = pd.read_csv(\n    Path.cwd().joinpath(\"..\").joinpath(collision_filename),\n    index_col=\"COLLISION_ID\",\n    usecols=cols_requested,\n    dtype=crash_dtypes,\n    converters=convert_cols,\n)\n\n\n\n\nRename some of the DataFrame columns\noriginal_col_names = crash.columns.to_list()\n\n# Rename the columns using the list of new names, 'cols_rename'\ncrash.rename(columns=cols_rename, inplace=True)\n\nprint(\"Original Crash Column Names\\n{}\".format(original_col_names))\nprint(\"\\nRenamed Crash Columns Names\\n{}\".format(crash.columns.to_list()))\n\n\nOriginal Crash Column Names\n['CRASH DATE', 'CRASH TIME', 'BOROUGH', 'ZIP CODE', 'LOCATION', 'ON STREET NAME', 'CROSS STREET NAME', 'OFF STREET NAME', 'NUMBER OF PERSONS INJURED', 'NUMBER OF PERSONS KILLED', 'NUMBER OF PEDESTRIANS INJURED', 'NUMBER OF PEDESTRIANS KILLED', 'NUMBER OF CYCLIST INJURED', 'NUMBER OF CYCLIST KILLED', 'NUMBER OF MOTORIST INJURED', 'NUMBER OF MOTORIST KILLED']\n\nRenamed Crash Columns Names\n['DATE', 'TIME', 'BOROUGH', 'ZIP_CODE', 'LOCATION', 'ON_STREET_NAME', 'CROSS_STREET_NAME', 'OFF_STREET_NAME', 'NUM_PERSONS_INJURED', 'NUM_PERSONS_KILLED', 'NUM_PEDESTRIANS_INJURED', 'NUM_PEDESTRIANS_KILLED', 'NUM_CYCLISTS_INJURED', 'NUM_CYCLISTS_KILLED', 'NUM_MOTORISTS_INJURED', 'NUM_MOTORISTS_KILLED']\n\n\n\n\nCode - Convert string values to numeric for specific ‘numeric’ columns.\n# Ensure that the 'numeric_cols' column values are numeric and not string values\nconvert_to_numeric(crash, numeric_cols)\n\n\n\n\nCode - General Description of the ‘crash’ dataset\n#  General Description of the dataset.\n\n# The 'set_option' is used here to display numeric values as a 'float' rather\n# than the default scientific notation\npd.set_option(\"display.float_format\", lambda x: \"%8.2f\" % x)\ncrash.describe()\n\n\n\n\n\n\n\n\n\nNUM_PERSONS_INJURED\nNUM_PERSONS_KILLED\nNUM_PEDESTRIANS_INJURED\nNUM_PEDESTRIANS_KILLED\nNUM_CYCLISTS_INJURED\nNUM_CYCLISTS_KILLED\nNUM_MOTORISTS_INJURED\nNUM_MOTORISTS_KILLED\n\n\n\n\ncount\n2017370.00\n2017370.00\n2017370.00\n2017370.00\n2017370.00\n2017370.00\n2017370.00\n2017370.00\n\n\nmean\n0.30\n0.00\n0.06\n0.00\n0.03\n0.00\n0.22\n0.00\n\n\nstd\n0.69\n0.04\n0.24\n0.03\n0.16\n0.01\n0.65\n0.03\n\n\nmin\n0.00\n0.00\n0.00\n0.00\n0.00\n0.00\n0.00\n0.00\n\n\n25%\n0.00\n0.00\n0.00\n0.00\n0.00\n0.00\n0.00\n0.00\n\n\n50%\n0.00\n0.00\n0.00\n0.00\n0.00\n0.00\n0.00\n0.00\n\n\n75%\n0.00\n0.00\n0.00\n0.00\n0.00\n0.00\n0.00\n0.00\n\n\nmax\n43.00\n8.00\n27.00\n6.00\n4.00\n2.00\n43.00\n5.00\n\n\n\n\n\n\n\n\n\nThe count tells us that there are over 2M rows of data. The maximum(max) NUM_PERSONS_INJURED in one collision is 43.\nThe average(mean) NUM_PERSONS_INJURED per collision is 0.3, or almost 1 for every three collisions. You can find more details on the pandas.DataFrame.describe function here.\n\n\n\n\nThe original ‘DATE’ is a “date only” field without the time. After merging the date and time columns, convert ‘DATE’ to a Python “datetime” object. Then remove the now unnecessary ‘TIME’ column.\n\n\n\nCode - Combine the DATE and TIME columns into the DATE column\n# Merge\ncrash[\"DATE\"] = pd.to_datetime(crash[\"DATE\"] + \" \" + crash[\"TIME\"])\n# Remove the 'TIME' column\ncrash.drop(columns=[\"TIME\"], inplace=True)\n# Convert to Python 'datetime'\ncrash[\"DATE\"] = pd.to_datetime(crash[\"DATE\"])\n\n\n\ncrash[\"DATE\"].describe()\n\ncount                          2017370\nmean     2017-05-13 17:54:54.650598912\nmin                2012-07-01 00:05:00\n25%                2014-12-19 13:00:15\n50%                2017-03-29 10:07:30\n75%                2019-06-09 17:50:00\nmax                2023-08-12 23:56:00\nName: DATE, dtype: object\n\n\n\n\n\nWe can see that the first collision record (min) was on July 8, 2012 The last record (max), for this iteration is August 12, 2023.\n\n\nCode - Create a ‘start_date’ and an ‘end_date’ variable.\n# Create a 'start_date' and 'end_date' variable, which is useful for our charts\nstart_date = crash[\"DATE\"].dt.date.min()\nend_date = crash[\"DATE\"].dt.date.max()\n\nprint(\"Start Date: {0} - End Date: {1}\".format(start_date, end_date))\n\n\nStart Date: 2012-07-01 - End Date: 2023-08-12\n\n\n\n\n\n\n\n\nThe Unknown Borough\n\n\n\nThe BOROUGH column should contain one of the 5 boroughs of New York City, BROOKLYN, BRONX, MANHATTAN, QUEENS and STATEN ISLAND.\nUnfortunately, many of the ‘BOROUGH’ fields are empty, as the NYPD don’t record it in certain situations.\nFor example, if the collision occurred on one of the main bridges between boroughs, or if the collision occurred on any one of NYC’s many expressways or parkways.\nFurther investigation would be needed to confirm this.\nI previously reached out to the open data team for more information on this, but got no reply.\n\n\n\n\nCode - Replace empty ‘BOROUGH’ values with ‘UNKNOWN’\ncrash.fillna(value={\"BOROUGH\": \"UNKNOWN\"}, inplace=True)\n\n\n\n\nCode - Describe the ‘BOROUGH’ column\ncrash[\"BOROUGH\"].describe()\n\n\ncount     2017370\nunique          6\ntop       UNKNOWN\nfreq       627585\nName: BOROUGH, dtype: object\n\n\n\n\n\n\nunique\n\nUnique borough name count, which includes the ‘UNKNOWN’ borough\n\ntop\n\n‘UNKNOWN’ is the most frequent borough recorded\n\nfreq\n\nTells us the occurrence of ‘UNKNOWN’ borough records\n\ncount\n\nHow many rows of data in the dataset\n\n\n\n\n\n\n\nCode - Replace empty ZIP_CODE’s with ‘UNKNOWN’\n# Replace empty ZIP_CODE's with 'UNKNOWN'\ncrash.fillna(value={\"ZIP_CODE\": \"UNKNOWN\"}, inplace=True)\n\n\n\n\n\n\n\n\nThe Unknown Zip Code\n\n\n\nAs with the BOROUGH column, the postal ZIP_CODE is often left empty.\nEmpty Zips will be replaced by ‘UNKNOWN’.\n\n\n\n\nCode - Describe the ‘ZIP_CODE’ column\ncrash[\"ZIP_CODE\"].describe()\n\n\ncount     2017370\nunique        235\ntop       UNKNOWN\nfreq       627823\nName: ZIP_CODE, dtype: object\n\n\n\n\n\nUsing crash['ZIP_CODE'].describe(), we see that the ZIP_CODE with the most collisions, top, is 11207, in Brooklyn.\nThe freq gives a count of collisions for this zip code. 11207 has a large population, almost 80,000 people, which may account for these numbers. A future project would be to see how these zip code counts relate to their population. The unique number tells us that there are 234 NYC zip codes with recorded collisions in this dataset.\n\n\n\n\n\nCode - Create new columns, YEAR, MONTH_NAME, DAY_NAME and HOUR\n#  by extracting information from the *DATE* column\n\n# Set up some date columns: YEAR, MONTH_NAME, DAY_NAME, HOUR\n# Remove all records for 2012 as it's only a partial year.\n\ncrash[\"YEAR\"] = crash[\"DATE\"].dt.year\n\n# Get rid of 2012 as it only has 6 months of data\nno_2012_mask = crash[\"YEAR\"] &gt; 2012\ncrash = crash[no_2012_mask]\n\n# Reset the start_date variable to reflect the change\nstart_date = crash[\"DATE\"].dt.date.min()\nyear_order = crash[\"YEAR\"].sort_values().unique()\n\n# Create a MONTH_NAME column. Actually, month abbreviated name\ncrash[\"MONTH_NAME\"] = crash[\"DATE\"].dt.month_name().str[0:3]\n\n# Create a HOUR column, which reflects the hour of day that the collision occurred\ncrash[\"HOUR\"] = crash[\"DATE\"].dt.strftime(\"%H\")\n\n# Need to convert hour_order to a Python list instead of Numpy array\nhour_order = crash[\"HOUR\"].sort_values().unique().tolist()\n\ncrash[\"DAY_NAME\"] = crash[\"DATE\"].dt.strftime(\"%a\")\n\nprint(\"Year, Month and Hour order lists will be used for charting.\")\nprint(\"Year order: {}\\n\".format(year_order))\nprint(\"Month abbreviations: {}\\n\".format(crash.MONTH_NAME.unique()))\nprint(\"Hour order: {}\\n\".format(hour_order))\n\n\nYear, Month and Hour order lists will be used for charting.\nYear order: [2013 2014 2015 2016 2017 2018 2019 2020 2021 2022 2023]\n\nMonth abbreviations: ['Sep' 'Mar' 'Jun' 'Dec' 'Apr' 'Jul' 'Feb' 'Aug' 'Nov' 'May' 'Jan' 'Oct']\n\nHour order: ['00', '01', '02', '03', '04', '05', '06', '07', '08', '09', '10', '11', '12', '13', '14', '15', '16', '17', '18', '19', '20', '21', '22', '23']\n\n\n\n\n\n\n\n\nThis chart will give an overview of the total deaths and injuries on NYC roads.\n\n\n\nCode - Create the yearly Killed/Injured collections.\ncrash_by_year_killed = (\n    crash.groupby(\"YEAR\")[\"NUM_PERSONS_KILLED\"].sum().sort_values(ascending=False)\n)\ncrash_by_year_injured = (\n    crash.groupby(\"YEAR\")[\"NUM_PERSONS_INJURED\"].sum().sort_values(ascending=False)\n)\n\n\n\n\nCode - Create Matplotlib bar chart with yearly details on the number of people killed and injured.\nkilled_injured = {\n    \"Killed\": crash_by_year_killed.loc[year_order],\n    \"Injured\": crash_by_year_injured.loc[year_order],\n}\n\nx_loc = np.arange(len(year_order))  # the label locations\nwidth = 0.45  # the width of the bars\nmultiplier = 0\nfig, ax = plt.subplots(figsize=(10, 15), layout=\"constrained\")\n\n# Create the Injured/Killed bars for each year\nfor killed_or_injured, count in killed_injured.items():\n    offset = width * multiplier\n    rects = ax.bar(x_loc + offset, count, width, label=killed_or_injured)\n    ax.bar_label(rects, padding=3)\n    multiplier += 1\n\n# Add some text for labels, title and custom x-axis tick labels, etc.\nax.set_xlabel(\"Year\", fontsize=14)\nax.set_ylabel(\"Killed/Injured Count\", fontsize=14)\nax.set_title(\n    \"Persons Killed and Injured From {0} to {1}\".format(start_date, end_date),\n    fontsize=20,\n)\nax.set_xticks(x_loc + (width / 2), year_order)\nax.legend(loc=\"upper left\")\nax.set_yscale(\"log\")\nplt.show()\n\n\n\n\n\n\n\nThe chart shows that traffic fatalities had a general downward trend from the high of 297 in 2013 to a low of 231 in 2018. The trend is upwards from 2019 to 2021, which was just 1 off the worst year, 2013. For injuries, 2016 to 2019 were the worst. The following years are a slight improvement, but no visible downward trend yet.\n\n\n\n\nFor each category, Person, Pedestrian, Cyclist and Motorist there will be a new ‘CASUALTY’ column with the combined Injured/Killed values\nThe new columns are, PERSON_CASUALTY_COUNT, PEDESTRIAN_CASUALTY_COUNT, CYCLIST_CASUALTY_COUNT and MOTORIST_CASUALTY_COUNT\n\n\n\nCode - Combine the INJURED and KILLED columns into one ‘CASUALTIES’ column.\ncrash[\"PERSON_CASUALTY_COUNT\"] = crash.NUM_PERSONS_INJURED + crash.NUM_PERSONS_KILLED\ncrash[\"PEDESTRIAN_CASUALTY_COUNT\"] = (\n    crash.NUM_PEDESTRIANS_INJURED + crash.NUM_PEDESTRIANS_KILLED\n)\n\ncrash[\"CYCLIST_CASUALTY_COUNT\"] = crash.NUM_CYCLISTS_INJURED + crash.NUM_CYCLISTS_KILLED\ncrash[\"MOTORIST_CASUALTY_COUNT\"] = (\n    crash.NUM_MOTORISTS_INJURED + crash.NUM_MOTORISTS_KILLED\n)\n\nkilled_injured_mask = (crash.NUM_PERSONS_KILLED &gt; 0) & (crash.NUM_PERSONS_INJURED &gt; 0)\n\n\n\n\n\n\nA function to print value counts above or to the side of Barchart bars.\nI got the original function from this very useful site, statology.org.\nThe original function is here.\n\n\n\nCode - Function to print value counts above or to the side of barchart bars\ndef show_values(axs, orient=\"v\", space=0.01):\n    def _single(ax):\n        if orient == \"v\":\n            for p in ax.patches:\n                _x = p.get_x() + p.get_width() / 2\n                _y = p.get_y() + p.get_height() + (p.get_height() * 0.01)\n                value = \"{:6,.0f}\".format(p.get_height())\n                ax.text(_x, _y, value, ha=\"center\", fontsize=12)\n        elif orient == \"h\":\n            for p in ax.patches:\n                _x = p.get_x() + p.get_width() + float(space)\n                _y = p.get_y() + p.get_height() - (p.get_height() * 0.5)\n                value = \"{:6,.0f}\".format(p.get_width())\n                ax.text(_x, _y, value, ha=\"left\", fontsize=12)\n\n    if isinstance(axs, np.ndarray):\n        for idx, ax in np.ndenumerate(axs):\n            _single(ax)\n    else:\n        _single(axs)\n\n\n\n\nCode - Helper functions for creating multiple charts based on Grouped statistics.\n# Statistics will be created for the below columns.\n#   PERSON_CASUALTY_COUNT\n#   PEDESTRIAN_CASUALTY_COUNT\n#   CYCLIST_CASUALTY_COUNT\n#   MOTORIST_CASUALTY_COUNT\n\n\ndef create_grouped_casualty_data_by_category(\n    victim_categories, time_group=\"YEAR\", order_list=None\n):\n    \"\"\"\n    Create multiple Seaborn SubPlot charts based on:\n    PERSON_CASUALTY_COUNT, PEDESTRIAN_CASUALTY_COUNT, CYCLIST_CASUALTY_COUNT and MOTORIST_CASUALTY_COUNT\n    time_group can be 'HOUR', 'DAY_OF_WEEK', 'MONTH_NAME', 'YEAR'\n    \"\"\"\n    time_group = time_group.upper()\n    all_casualty_data = []\n\n    for category in victim_categories:\n        cat_upper = category.upper()\n        casualty_label = cat_upper + \"_CASUALTY_COUNT\"\n\n        casualty_data = crash.groupby(by=[time_group], as_index=True).agg(\n            {casualty_label: \"sum\"}\n        )\n        if order_list and len(order_list):\n            casualty_data = casualty_data.loc[order_list]\n\n        category_data = {\n            \"category\": category,\n            \"casualty_label\": casualty_label,\n            \"casualty_data\": casualty_data,\n        }\n\n        all_casualty_data.append(category_data)\n    return all_casualty_data\n\n\ndef create_bar_plots_for_casualty_data(sns, axes, order_list, crash_victims_data):\n    for idx, category_data in enumerate(crash_victims_data):\n        xlabel = None\n        ylabel = None\n        # Casualty Chart\n        category_title = category_data[\"category\"].title()\n        chart_title = \"{0} Casualties\".format(category_title)\n\n        casualty_max = category_data[\"casualty_data\"][\n            category_data[\"casualty_label\"]\n        ].max()\n        casualty_values = category_data[\"casualty_data\"][\n            category_data[\"casualty_label\"]\n        ].to_list()\n\n        casualty_colors = [\n            \"k\" if (x &gt;= casualty_max) else \"tab:red\" for x in casualty_values\n        ]\n\n        ax = axes[idx]\n\n        sns.barplot(\n            data=category_data[\"casualty_data\"],\n            x=order_list,\n            order=order_list,\n            y=category_data[\"casualty_label\"],\n            palette=casualty_colors,\n            ax=ax,\n        ).set(title=chart_title, xlabel=xlabel, ylabel=ylabel)\n\n        show_values(axes)\n\n\n\n\nCode - Set some global Matplotlib/Seaborn chart variables.\ntitle_fontsize = 20\nlabel_fontsize = 18\n# For spacing between charts on the same grid\ngridspec_kw = {\"wspace\": 0.1, \"hspace\": 0.1}\n\nsns.set_style(\"whitegrid\")\n\n\n\n\n\n\n\n2018 was the worst for human casualties, with 62,172 injuries and deaths. 2019 was a close second, followed by 2017 and 2016.\n\nCyclists - 2020 was by far the worst year with 5,605 casualties.\nMotorists - 2018 was their worst year with 46,168 casualties.\nPedestrians - 2013 was their worst year with 12,164 casualties. Things have improved a little for them since then.\n\n\n\nCode - Create Seaborn charts for crash casualties based on year.\ncol_ct = 1\n#  Create the outer figure box\nfig, axes = plt.subplots(\n    4, col_ct, figsize=(15, 40), layout=\"constrained\", gridspec_kw=gridspec_kw\n)\nfig.suptitle(\n    \"Total Yearly Crash Casualties from {0} to {1} by Category\".format(\n        start_date, end_date\n    ),\n    fontsize=title_fontsize,\n)\nfig.supxlabel(\"Year\", fontsize=label_fontsize)\nfig.supylabel(\"Counts\", fontsize=label_fontsize)\n\ncrash_casualty_data = create_grouped_casualty_data_by_category(\n    victim_categories, \"year\"\n)\ncreate_bar_plots_for_casualty_data(sns, axes, year_order, crash_casualty_data)\n\n\n\n\n\n\n\n\nJune has been the worst month for human casualties, with 56,240 injuries and deaths.\nThe Summer months in general seem to be bad for motorists and cyclists, while winter is bad for pedestrians.\n\nCyclists - July has been the worst, with 6,270 casualties. August and June follow after that.\nMotorists - July has been the worst, with 41,140 casualties. June is a close second.\nPedestrians - December has been the worst, with 10,750 casualties. January is a close second.\n\nWinter time may be a good time to stay on public transport or indoors.\n\n\n\n\nCode - Create Seaborn charts for crash casualties based on month.\n# Create the outer figure box\ncol_ct = 1\nfig, axes = plt.subplots(\n    4, col_ct, figsize=(20, 30), layout=\"constrained\", gridspec_kw=gridspec_kw\n)\n\nfig.suptitle(\n    \"Total Monthly Crash Casualties from {0} to {1} by Category\".format(\n        start_date, end_date\n    ),\n    fontsize=title_fontsize,\n)\nfig.supxlabel(\"Month\", fontsize=label_fontsize)\nfig.supylabel(\"Counts\", fontsize=label_fontsize)\n\ncrash_casualty_data = create_grouped_casualty_data_by_category(\n    victim_categories, \"month_name\", month_abbr_order\n)\ncreate_bar_plots_for_casualty_data(sns, axes, month_abbr_order, crash_casualty_data)\n\n\n\n\n\n\n\n\nFriday tends to be the worst day for human casualties, with 90,089 injuries and deaths. Sunday seems to be the safest.\n\nCyclists - Friday is a bad day to bike in NYC, with 8,008 casualties since the start of 2013.\nMotorists - Friday and Saturday are equally bad, with 63,774 casualties each.\nPedestrians - Pedestrians should also avoid Fridays, with 17,337 casualties since the start of 2013.\n\n\n\nCode - Create Seaborn charts for crash casualties based on day of the week.\ncol_ct = 1\nfig, axes = plt.subplots(\n    4, col_ct, figsize=(15, 40), layout=\"constrained\", gridspec_kw=gridspec_kw\n)\n\nfig.suptitle(\n    \"Total Day of Week Crash Casualties from {0} to {1} by Category\".format(\n        start_date, end_date\n    ),\n    fontsize=title_fontsize,\n)\nfig.supxlabel(\"Day of Week\", fontsize=label_fontsize)\nfig.supylabel(\"Counts\", fontsize=label_fontsize)\n\n# crash.set_index('MONTH_NAME').loc[month_abbr_order].groupby(by=['MONTH_NAME']).agg({'PEDESTRIAN_CASUALTY_COUNT': 'sum'}).plot(kind='bar')\ncrash_casualty_data = create_grouped_casualty_data_by_category(\n    victim_categories, \"day_name\", day_abbr_order\n)\ncrash_casualty_data\ncreate_bar_plots_for_casualty_data(sns, axes, day_abbr_order, crash_casualty_data)\n\n\n\n\n\n\n\n\nThe hour between 5 and 6 pm is the worst time for human casualties, with 40,777 injuries and deaths. The rush-hour times around 5 pm have a high casualty count. The morning rush hour also trends higher, but much lower than the evening rush-hour.\nThe early hours of the morning between 12 and 1 am also having a high body count. This is at a time when you would expect the traffic volume to be low.\n\nCyclists - Follow the trend with 4,167 casualties between 5 and 6 pm.\nMotorists - Get off to an earlier start, with 28,142 casualties between 4 and 5 pm.\nPedestrians - Pedestrians get hit at higher rates between 5 and 6 pm, with 8,6623 casualties since the start of 2013.\n\n\n\nCode - Create Seaborn charts for crash casualties based on the Hour of day.\n#  Create the outer figure box\ncol_ct = 1\nfig, axes = plt.subplots(\n    4, col_ct, figsize=(15, 40), layout=\"constrained\", gridspec_kw=gridspec_kw\n)\n\nfig.suptitle(\n    \"Total Hour of Day Crash Casualties from {0} to {1} by Category\".format(\n        start_date, end_date\n    ),\n    fontsize=title_fontsize,\n)\nfig.supxlabel(\"Hour of Day\", fontsize=label_fontsize)\nfig.supylabel(\"Counts\", fontsize=label_fontsize)\n\ncrash_casualty_data = create_grouped_casualty_data_by_category(\n    victim_categories, \"hour\", hour_order\n)\n\n#  Create the inner charts\ncreate_bar_plots_for_casualty_data(sns, axes, hour_order, crash_casualty_data)\n\n\n\n\n\n\n\n\nNo major surprises with most of the data. Most injuries and deaths occur during the evening rush hour, when traffic volume is at its highest and people are in a rush to get home. This is particularly evident on Fridays, when the urge to get home seems to be the greatest.\nI’m still curious as to why more motorist casualties on Saturday are equal to the Friday’s total. It could be because of Friday night “madness” or some other reason. I’d like to spend more time digging into that.\nIt’s also not too surprising that the cyclists are getting mowed down more often in the Summer months, as there are probably a lot more bikes on the road during those times.\nFor pedestrians, the upward trend in casualties from October to January is a little surprising. The December peak may be because of holiday shopping and holiday parties? That’s something I’ll spend more time analyzing in the future.\n\n\n\nThis Project on GitHub\nMe on Linkedin\n\n\nNYC Streetsblog\nHellgateNYC\nNYC Open Data\nnbdev really helped setup this blog post"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "crash_stats",
    "section": "",
    "text": "This file will become your README and also the index of your documentation."
  },
  {
    "objectID": "index.html#install",
    "href": "index.html#install",
    "title": "crash_stats",
    "section": "Install",
    "text": "Install\npip install crash_stats"
  },
  {
    "objectID": "index.html#how-to-use",
    "href": "index.html#how-to-use",
    "title": "crash_stats",
    "section": "How to use",
    "text": "How to use\nFill me in please! Don’t forget code examples:\n\n1+1\n\n2"
  },
  {
    "objectID": "crash_time_period_stats.html#focusing-on-casualty-statistics-over-different-time-periods",
    "href": "crash_time_period_stats.html#focusing-on-casualty-statistics-over-different-time-periods",
    "title": "NYC Collision Data Analysis",
    "section": "",
    "text": "...what time of day? \n...what month of the year? \nhas the most traffic collision related human casualties in New York City?  \nUsing the open traffic collisions data available from NYPD.\nYou can skip the explanations and go straight to the results.\nOr, you can read on and see how I came up with these numbers using Python and the pandas library.\n\n\nCode - Import All Required Python Modules\n# Import All Required Python Modules\nimport numpy as np\nimport pandas as pd\nimport datetime\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nfrom pathlib import Path\n\n\n\n\nCode - Data Formatting Functions\n# Data Formatting Functions\n\ndef empty_to_zero(val):\n    '''Converts empty values to 0'''\n    val = val.strip('\\s+')\n    return val if len(val) else 0\n\n\ndef convert_to_numeric(df, column_list):\n    '''Given a list of DataFrame columns, it converts the empty values to zero'''\n    df[column_list] = df[column_list].apply(pd.to_numeric, errors='coerce')\n\n\n\n\nCode - Set Up Some Global Variables\n# Set Up Some Global Variables\n\n# I'm omitting longitude, latitude, the vehicle types as well as crash contributing factors.\ncols_requested = ['COLLISION_ID', 'CRASH DATE', 'CRASH TIME', 'BOROUGH', 'ZIP CODE', 'LOCATION', 'ON STREET NAME', 'CROSS STREET NAME', 'OFF STREET NAME', 'NUMBER OF PERSONS INJURED',\n                  'NUMBER OF PERSONS KILLED', 'NUMBER OF PEDESTRIANS INJURED', 'NUMBER OF PEDESTRIANS KILLED', 'NUMBER OF CYCLIST INJURED', 'NUMBER OF CYCLIST KILLED', 'NUMBER OF MOTORIST INJURED', 'NUMBER OF MOTORIST KILLED']\n\n# To ensure that the colums are of the expected data type\ncrash_dtypes = {'CRASH DATE': str,\n                'CRASH TIME': str,\n                'BOROUGH': str,\n                'ZIP CODE': str,\n                'LOCATION': str,\n                'ON STREET NAME': str,\n                'CROSS STREET NAME': str,\n                'OFF STREET NAME': str,\n                }\n\n# Rename some colums to ones that I believe are shorter and/or more meaningful\ncols_rename = {'CRASH DATE': 'DATE',\n               'CRASH TIME': 'TIME',\n               'ZIP CODE': 'ZIP_CODE',\n               'ON STREET NAME': 'ON_STREET_NAME',\n               'CROSS STREET NAME': 'CROSS_STREET_NAME',\n               'OFF STREET NAME': 'OFF_STREET_NAME',\n               'NUMBER OF PERSONS INJURED': 'NUM_PERSONS_INJURED',\n               'NUMBER OF PERSONS KILLED': 'NUM_PERSONS_KILLED',\n               'NUMBER OF PEDESTRIANS INJURED': 'NUM_PEDESTRIANS_INJURED',\n               'NUMBER OF PEDESTRIANS KILLED': 'NUM_PEDESTRIANS_KILLED',\n               'NUMBER OF CYCLIST INJURED': 'NUM_CYCLISTS_INJURED',\n               'NUMBER OF CYCLIST KILLED': 'NUM_CYCLISTS_KILLED',\n               'NUMBER OF MOTORIST INJURED': 'NUM_MOTORISTS_INJURED',\n               'NUMBER OF MOTORIST KILLED': 'NUM_MOTORISTS_KILLED'\n               }\n\n# Columns that contain numeric values\nnumeric_cols = ['NUM_PERSONS_INJURED',\n                'NUM_PERSONS_KILLED',\n                'NUM_PEDESTRIANS_INJURED',\n                'NUM_PEDESTRIANS_KILLED',\n                'NUM_CYCLISTS_INJURED',\n                'NUM_CYCLISTS_KILLED',\n                'NUM_MOTORISTS_INJURED',\n                'NUM_MOTORISTS_KILLED']\n\n# These ordered lists are useful for plotting charts\nday_names_order = [\"Monday\", \"Tuesday\", \"Wednesday\",\n                   \"Thursday\", \"Friday\", \"Saturday\", \"Sunday\"]\nday_abbr_order = [d[0:3] for d in day_names_order]\nmonth_names_order = [\"January\", \"February\", \"March\", \"April\", \"May\",\n                     \"June\", \"July\", \"August\", \"September\", \"October\", \"November\", \"December\"]\nmonth_abbr_order = [m[0:3] for m in month_names_order]\n\n# The following DataFrame columns that will have their empty values converted to zero using the\n# 'empty_to_zero' function\nconvert_cols = {\n    'NUMBER OF PERSONS INJURED': empty_to_zero,\n    'NUMBER OF PERSONS KILLED':  empty_to_zero,\n    'NUMBER OF PEDESTRIANS INJURED': empty_to_zero,\n    'NUMBER OF PEDESTRIANS KILLED': empty_to_zero,\n    'NUMBER OF CYCLIST INJURED': empty_to_zero,\n    'NUMBER OF CYCLIST KILLED': empty_to_zero,\n    'NUMBER OF MOTORIST INJURED': empty_to_zero,\n    'NUMBER OF MOTORIST KILLED': empty_to_zero\n}\n\n# These are the 4 categories supplied by the NYPD\nvictim_categories = ['person', 'cyclist', 'motorist', 'pedestrian']\n# 'person' status should be a combination of the other three categories\n# TODO I need to verify the relationship between 'person' and the other three categories\n\n# These are the Matplotlib Tableau colors\nbar_colors = ['tab:blue', 'tab:orange', 'tab:green', 'tab:red',\n              'tab:purple', 'tab:brown', 'tab:pink', 'tab:gray', 'tab:olive', 'tab:cyan']\n\nbase_colors = ['b', 'g', 'r', 'c', 'm', 'y', 'k', 'w']\n\n# Chart Colors\ncolor = 'k'\nplt.rcParams['text.color'] = color\nplt.rcParams['axes.labelcolor'] = color\nplt.rcParams['xtick.color'] = 'b'\nplt.rcParams['ytick.color'] = 'b'\n\n\n\n\n\nThe Collision Dataset provided by NYPD is available here.\n\n\n\nCode - Creating the ‘crash’ DataFrame from the NYPD CSV file.\ncollision_filename = \"Motor_Vehicle_Collisions_Aug15_2023.csv\"\n\n# Using the Pandas 'read_csv' function\ncrash = pd.read_csv(Path.cwd().joinpath(\"..\").joinpath(collision_filename),\n                    index_col='COLLISION_ID', usecols=cols_requested, dtype=crash_dtypes, converters=convert_cols)\n\n\n\n\nRename some of the DataFrame columns\noriginal_col_names = crash.columns.to_list()\n\n# Rename the columns using the list of new names, 'cols_rename'\ncrash.rename(columns=cols_rename, inplace=True)\n\nprint(\"Original Crash Column Names\\n{}\".format(original_col_names))\nprint(\"\\nRenamed Crash Columns Names\\n{}\".format(crash.columns.to_list()))\n\n\nOriginal Crash Column Names\n['CRASH DATE', 'CRASH TIME', 'BOROUGH', 'ZIP CODE', 'LOCATION', 'ON STREET NAME', 'CROSS STREET NAME', 'OFF STREET NAME', 'NUMBER OF PERSONS INJURED', 'NUMBER OF PERSONS KILLED', 'NUMBER OF PEDESTRIANS INJURED', 'NUMBER OF PEDESTRIANS KILLED', 'NUMBER OF CYCLIST INJURED', 'NUMBER OF CYCLIST KILLED', 'NUMBER OF MOTORIST INJURED', 'NUMBER OF MOTORIST KILLED']\n\nRenamed Crash Columns Names\n['DATE', 'TIME', 'BOROUGH', 'ZIP_CODE', 'LOCATION', 'ON_STREET_NAME', 'CROSS_STREET_NAME', 'OFF_STREET_NAME', 'NUM_PERSONS_INJURED', 'NUM_PERSONS_KILLED', 'NUM_PEDESTRIANS_INJURED', 'NUM_PEDESTRIANS_KILLED', 'NUM_CYCLISTS_INJURED', 'NUM_CYCLISTS_KILLED', 'NUM_MOTORISTS_INJURED', 'NUM_MOTORISTS_KILLED']\n\n\n\n\nCode - Convert string values to numeric for specific ‘numeric’ columns.\n# Ensure that the 'numeric_cols' column values are numeric and not string values\nconvert_to_numeric(crash, numeric_cols)\n\n\n\n\nCode - General Description of the ‘crash’ dataset\n#  General Description of the dataset.\n\n# The 'set_option' is used here to display numeric values as a 'float' rather\n# than the default scientific notation\npd.set_option('display.float_format', lambda x: '%8.2f' % x)\ncrash.describe()\n\n\n\n\n\n\n\n\n\nNUM_PERSONS_INJURED\nNUM_PERSONS_KILLED\nNUM_PEDESTRIANS_INJURED\nNUM_PEDESTRIANS_KILLED\nNUM_CYCLISTS_INJURED\nNUM_CYCLISTS_KILLED\nNUM_MOTORISTS_INJURED\nNUM_MOTORISTS_KILLED\n\n\n\n\ncount\n2017370.00\n2017370.00\n2017370.00\n2017370.00\n2017370.00\n2017370.00\n2017370.00\n2017370.00\n\n\nmean\n0.30\n0.00\n0.06\n0.00\n0.03\n0.00\n0.22\n0.00\n\n\nstd\n0.69\n0.04\n0.24\n0.03\n0.16\n0.01\n0.65\n0.03\n\n\nmin\n0.00\n0.00\n0.00\n0.00\n0.00\n0.00\n0.00\n0.00\n\n\n25%\n0.00\n0.00\n0.00\n0.00\n0.00\n0.00\n0.00\n0.00\n\n\n50%\n0.00\n0.00\n0.00\n0.00\n0.00\n0.00\n0.00\n0.00\n\n\n75%\n0.00\n0.00\n0.00\n0.00\n0.00\n0.00\n0.00\n0.00\n\n\nmax\n43.00\n8.00\n27.00\n6.00\n4.00\n2.00\n43.00\n5.00\n\n\n\n\n\n\n\n\n\n\nThe count tells us that there are over 2M rows of data. The maximum(max) NUM_PERSONS_INJURED in one collision is 43.\nThe average(mean) NUM_PERSONS_INJURED per collision is 0.3, or almost 1 for every three collisions. You can find more details on the pandas.DataFrame.describe function here.\n\n\n\n\nThe original ‘DATE’ is a “date only” field without the time. After merging the date and time columns, convert ‘DATE’ to a Python “datetime” object. Then remove the now unnecessary ‘TIME’ column.\n\n\n\nCode - Combine the DATE and TIME columns into the DATE column\n# Merge\ncrash['DATE'] = pd.to_datetime(crash['DATE'] + \" \" + crash['TIME'])\n# Remove the 'TIME' column\ncrash.drop(columns=['TIME'], inplace=True)\n# Convert to Python 'datetime'\ncrash['DATE'] = pd.to_datetime(crash['DATE'])\n\n\n\ncrash['DATE'].describe()\n\ncount                          2017370\nmean     2017-05-13 17:54:54.650598912\nmin                2012-07-01 00:05:00\n25%                2014-12-19 13:00:15\n50%                2017-03-29 10:07:30\n75%                2019-06-09 17:50:00\nmax                2023-08-12 23:56:00\nName: DATE, dtype: object\n\n\n\n\n\nWe can see that the first collision record (min) was on July 8, 2012 The last record (max), for this iteration is August 12, 2023.\n\n\nCode - Create a ‘start_date’ and an ‘end_date’ variable.\n# Create a 'start_date' and 'end_date' variable, which is useful for our charts\nstart_date = crash['DATE'].dt.date.min()\nend_date = crash['DATE'].dt.date.max()\n\nprint(\"Start Date: {0} - End Date: {1}\".format(start_date, end_date))\n\n\nStart Date: 2012-07-01 - End Date: 2023-08-12\n\n\n\n\n\nThe BOROUGH column contains the 5 boroughs of New York City, BROOKLYN, BRONX, MANHATTAN, QUEENS and STATEN ISLAND.\nUnfortunately, many of the ‘BOROUGH’ fields are empty.\nThe NYPD don’t record the borough in certain situations. For example, if the collision occurred on one of the main bridges between boroughs, or if the collision occurred on any one of NYC’s many expressways or parkways. Further investigation would be needed to confirm this.\nI previously reached out to the open data team for more information on this, but got no reply.\n\n\nCode - Replace empty ‘BOROUGH’ values with ‘UNKNOWN’\ncrash.fillna(value={'BOROUGH': 'UNKNOWN'}, inplace=True)\ncrash['BOROUGH'].describe()\n\n\ncount     2017370\nunique          6\ntop       UNKNOWN\nfreq       627585\nName: BOROUGH, dtype: object\n\n\n\n\n\n\nunique\n\nUnique borough name count, which includes the ‘UNKNOWN’ borough\n\ntop\n\n‘UNKNOWN’ is the most frequent borough recorded\n\nfreq\n\nTells us the occurrence of ‘UNKNOWN’ borough records\n\ncount\n\nHow many rows of data in the dataset\n\n\n\n\n\n\n\nCode - Replace empty ZIP_CODE’s with ‘UNKNOWN’\n# Replace empty ZIP_CODE's with 'UNKNOWN'\ncrash.fillna(value={'ZIP_CODE': 'UNKNOWN'}, inplace=True)\ncrash['ZIP_CODE'].describe()\n\n\ncount     2017370\nunique        235\ntop       UNKNOWN\nfreq       627823\nName: ZIP_CODE, dtype: object\n\n\n\n\n\nAs with the BOROUGH column, the postal ZIP_CODE is often left empty. In this case, using crash['ZIP_CODE'].describe(), we see that the ZIP_CODE with the most collisions, top, is 11207 in Brooklyn.\nThe freq gives a count of collisions for this zip code. 11207 has a large population, almost 80,000 people, which may account for these numbers. A future project would be to see how these zip code counts relate to their population. The unique number tells us that there are 234 NYC zip codes with recorded collisions in this dataset.\n\n\n\n\n\nCode - Create new columns, YEAR, MONTH_NAME, DAY_NAME and HOUR\n#  by extracting information from the *DATE* column\n\n# Set up some date columns: YEAR, MONTH_NAME, DAY_NAME, HOUR\n# Remove all records for 2012 as it's only a partial year.\n\ncrash['YEAR'] = crash['DATE'].dt.year\n\n# Get rid of 2012 as it only has 6 months of data\nno_2012_mask = crash['YEAR'] &gt; 2012\ncrash = crash[no_2012_mask]\n\n# Reset the start_date variable to reflect the change\nstart_date = crash['DATE'].dt.date.min()\nyear_order = crash['YEAR'].sort_values().unique()\n\n# Create a MONTH_NAME column. Actually, month abbreviated name\ncrash['MONTH_NAME'] = crash['DATE'].dt.month_name().str[0:3]\n\n# Create a HOUR column, which reflects the hour of day that the collision occurred\ncrash['HOUR'] = crash['DATE'].dt.strftime(\"%H\")\n\n# Need to convert hour_order to a Python list instead of Numpy array\nhour_order = crash['HOUR'].sort_values().unique().tolist()\n\ncrash['DAY_NAME'] = crash['DATE'].dt.strftime(\"%a\")\n\nprint(\"Year, Month and Hour order lists will be used for charting.\")\nprint(\"Year order: {}\\n\".format(year_order))\nprint(\"Month abbreviations: {}\\n\".format(crash.MONTH_NAME.unique()))\nprint(\"Hour order: {}\\n\".format(hour_order))\n\n\nYear, Month and Hour order lists will be used for charting.\nYear order: [2013 2014 2015 2016 2017 2018 2019 2020 2021 2022 2023]\n\nMonth abbreviations: ['Sep' 'Mar' 'Jun' 'Dec' 'Apr' 'Jul' 'Feb' 'Aug' 'Nov' 'May' 'Jan' 'Oct']\n\nHour order: ['00', '01', '02', '03', '04', '05', '06', '07', '08', '09', '10', '11', '12', '13', '14', '15', '16', '17', '18', '19', '20', '21', '22', '23']\n\n\n\n\n\n\n\nThis chart will give an overview of the total deaths and injuries on NYC roads.\n\n\n\nCode - Create the yearly Killed/Injured collections.\ncrash_by_year_killed = crash.groupby(\n    'YEAR')['NUM_PERSONS_KILLED'].sum().sort_values(ascending=False)\ncrash_by_year_injured = crash.groupby(\n    'YEAR')['NUM_PERSONS_INJURED'].sum().sort_values(ascending=False)\n\n\n\n\nCode - Create Matplotlib bar chart with yearly details on the number of people killed and injured.\nkilled_injured = {\n    'Killed': crash_by_year_killed.loc[year_order], 'Injured': crash_by_year_injured.loc[year_order]}\n\nx_loc = np.arange(len(year_order))  # the label locations\nwidth = 0.45  # the width of the bars\nmultiplier = 0\nfig, ax = plt.subplots(figsize=(10, 15), layout='constrained')\n\n# Create the Injured/Killed bars for each year\nfor killed_or_injured, count in killed_injured.items():\n    offset = width * multiplier\n    rects = ax.bar(x_loc + offset, count, width, label=killed_or_injured)\n    ax.bar_label(rects, padding=3)\n    multiplier += 1\n\n# Add some text for labels, title and custom x-axis tick labels, etc.\nax.set_xlabel('Year', fontsize=14)\nax.set_ylabel('Killed/Injured Count', fontsize=14)\nax.set_title('Persons Killed and Injured From {0} to {1}'.format(\n    start_date, end_date), fontsize=20)\nax.set_xticks(x_loc + (width/2), year_order)\nax.legend(loc='upper left')\nax.set_yscale('log')\nplt.show()\n\n\n\n\n\n\n\nThe chart shows that traffic fatalities had a general downward trend from the high of 297 in 2013 to a low of 231 in 2018. The trend is upwards from 2019 to 2021, which was just 1 off the worst year, 2013. For injuries, 2016 to 2019 were the worst. The following years are a slight improvement, but no visible downward trend yet.\n\n\n\n\nFor each category, Person, Pedestrian, Cyclist and Motorist there will be a new ‘CASUALTY’ column with the combined Injured/Killed values\nThe new columns are, PERSON_CASUALTY_COUNT, PEDESTRIAN_CASUALTY_COUNT, CYCLIST_CASUALTY_COUNT and MOTORIST_CASUALTY_COUNT\n\n\n\nCode - Combine the INJURED and KILLED columns into one ‘CASUALTIES’ column.\ncrash['PERSON_CASUALTY_COUNT'] = crash.NUM_PERSONS_INJURED + \\\n    crash.NUM_PERSONS_KILLED\ncrash['PEDESTRIAN_CASUALTY_COUNT'] = crash.NUM_PEDESTRIANS_INJURED + \\\n    crash.NUM_PEDESTRIANS_KILLED\n\ncrash['CYCLIST_CASUALTY_COUNT'] = crash.NUM_CYCLISTS_INJURED + \\\n    crash.NUM_CYCLISTS_KILLED\ncrash['MOTORIST_CASUALTY_COUNT'] = crash.NUM_MOTORISTS_INJURED + \\\n    crash.NUM_MOTORISTS_KILLED\n\nkilled_injured_mask = (crash.NUM_PERSONS_KILLED &gt; 0) & (\n    crash.NUM_PERSONS_INJURED &gt; 0)\n\n\n\n\n\n\nA function to print value counts above or to the side of Barchart bars.\nI got the original function from this very useful site, statology.org.\nThe original function is here.\n\n\n\nCode - Function to print value counts above or to the side of barchart bars\ndef show_values(axs, orient=\"v\", space=.01):\n    def _single(ax):\n        if orient == \"v\":\n            for p in ax.patches:\n                _x = p.get_x() + p.get_width() / 2\n                _y = p.get_y() + p.get_height() + (p.get_height()*0.01)\n                value = '{:6,.0f}'.format(p.get_height())\n                ax.text(_x, _y, value, ha=\"center\", fontsize=12)\n        elif orient == \"h\":\n            for p in ax.patches:\n                _x = p.get_x() + p.get_width() + float(space)\n                _y = p.get_y() + p.get_height() - (p.get_height()*0.5)\n                value = '{:6,.0f}'.format(p.get_width())\n                ax.text(_x, _y, value, ha=\"left\", fontsize=12)\n\n    if isinstance(axs, np.ndarray):\n        for idx, ax in np.ndenumerate(axs):\n            _single(ax)\n    else:\n        _single(axs)\n\n\n\n\nCode - Helper functions for creating multiple charts based on Grouped statistics.\n# Statistics will be created for the below columns.\n#   PERSON_CASUALTY_COUNT\n#   PEDESTRIAN_CASUALTY_COUNT\n#   CYCLIST_CASUALTY_COUNT\n#   MOTORIST_CASUALTY_COUNT\n\ndef create_grouped_casualty_data_by_category(victim_categories, time_group=\"YEAR\", order_list=None):\n    ''' \n    Create multiple Seaborn SubPlot charts based on:\n    PERSON_CASUALTY_COUNT, PEDESTRIAN_CASUALTY_COUNT, CYCLIST_CASUALTY_COUNT and MOTORIST_CASUALTY_COUNT\n    time_group can be 'HOUR', 'DAY_OF_WEEK', 'MONTH_NAME', 'YEAR' \n    '''\n    time_group = time_group.upper()\n    all_casualty_data = []\n\n    for category in victim_categories:\n        cat_upper = category.upper()\n        casualty_label = cat_upper + '_CASUALTY_COUNT'\n\n        casualty_data = crash.groupby(\n            by=[time_group], as_index=True).agg({casualty_label: 'sum'})\n        if order_list and len(order_list):\n            casualty_data = casualty_data.loc[order_list]\n\n        category_data = {\n            'category': category,\n            'casualty_label': casualty_label,\n            'casualty_data':  casualty_data\n        }\n\n        all_casualty_data.append(category_data)\n    return all_casualty_data\n\n\ndef create_bar_plots_for_casualty_data(sns, axes, order_list, crash_victims_data):\n    for idx, category_data in enumerate(crash_victims_data):\n        xlabel = None\n        ylabel = None\n        # Casualty Chart\n        category_title = category_data['category'].title()\n        chart_title = \"{0} Casualties\".format(category_title)\n\n        casualty_max = category_data['casualty_data'][category_data['casualty_label']].max(\n        )\n        casualty_values = category_data['casualty_data'][category_data['casualty_label']].to_list(\n        )\n\n        casualty_colors = ['k' if (\n            x &gt;= casualty_max) else 'tab:red' for x in casualty_values]\n\n        ax = axes[idx]\n\n        sns.barplot(data=category_data['casualty_data'], x=order_list, order=order_list,\n                    y=category_data['casualty_label'], palette=casualty_colors, ax=ax).set(title=chart_title, xlabel=xlabel, ylabel=ylabel)\n\n        show_values(axes)\n\n\n\n\nCode - Set some global Matplotlib/Seaborn chart variables.\ntitle_fontsize = 20\nlabel_fontsize = 18\n# For spacing between charts on the same grid\ngridspec_kw = {'wspace': 0.1, 'hspace': 0.1}\n\nsns.set_style(\"whitegrid\")\n\n\n\n\n\n\n\n2018 was the worst for human casualties, with 62,172 injuries and deaths. 2019 was a close second, followed by 2017 and 2016.\n\nCyclists - 2020 was by far the worst year with 5,605 casualties.\nMotorists - 2018 was their worst year with 46,168 casualties.\nPedestrians - 2013 was their worst year with 12,164 casualties. Things have improved a little for them since then.\n\n\n\nCode - Create Seaborn charts for crash casualties based on year.\ncol_ct = 1\n#  Create the outer figure box\nfig, axes = plt.subplots(4, col_ct, figsize=(\n    15, 40), layout=\"constrained\", gridspec_kw=gridspec_kw)\nfig.suptitle(\"Total Yearly Crash Casualties from {0} to {1} by Category\".format(\n    start_date, end_date), fontsize=title_fontsize)\nfig.supxlabel(\"Year\", fontsize=label_fontsize)\nfig.supylabel(\"Counts\", fontsize=label_fontsize)\n\ncrash_casualty_data = create_grouped_casualty_data_by_category(\n    victim_categories, 'year')\ncreate_bar_plots_for_casualty_data(\n    sns, axes, year_order, crash_casualty_data)\n\n\n\n\n\n\n\n\nJune has been the worst month for human casualties, with 56,240 injuries and deaths.\nThe Summer months in general seem to be bad for motorists and cyclists, while winter is bad for pedestrians.\n\nCyclists - July has been the worst, with 6,270 casualties. August and June follow after that.\nMotorists - July has been the worst, with 41,140 casualties. June is a close second.\nPedestrians - December has been the worst, with 10,750 casualties. January is a close second.\n\nWinter time may be a good time to stay on public transport or indoors.\n\n\n\n\nCode - Create Seaborn charts for crash casualties based on month.\n# Create the outer figure box\ncol_ct = 1\nfig, axes = plt.subplots(4, col_ct, figsize=(\n    20, 30), layout=\"constrained\", gridspec_kw=gridspec_kw)\n\nfig.suptitle(\"Total Monthly Crash Casualties from {0} to {1} by Category\".format(\n    start_date, end_date), fontsize=title_fontsize)\nfig.supxlabel(\"Month\", fontsize=label_fontsize)\nfig.supylabel(\"Counts\", fontsize=label_fontsize)\n\ncrash_casualty_data = create_grouped_casualty_data_by_category(\n    victim_categories, 'month_name', month_abbr_order)\ncreate_bar_plots_for_casualty_data(\n    sns, axes, month_abbr_order, crash_casualty_data)\n\n\n\n\n\n\n\n\nFriday tends to be the worst day for human casualties, with 90,089 injuries and deaths. Sunday seems to be the safest.\n\nCyclists - Friday is a bad day to bike in NYC, with 8,008 casualties since the start of 2013.\nMotorists - Friday and Saturday are equally bad, with 63,774 casualties each.\nPedestrians - Pedestrians should also avoid Fridays, with 17,337 casualties since the start of 2013.\n\n\n\nCode - Create Seaborn charts for crash casualties based on day of the week.\ncol_ct = 1\nfig, axes = plt.subplots(4, col_ct, figsize=(\n    15, 40), layout=\"constrained\", gridspec_kw=gridspec_kw)\n\nfig.suptitle(\"Total Day of Week Crash Casualties from {0} to {1} by Category\".format(\n    start_date, end_date), fontsize=title_fontsize)\nfig.supxlabel(\"Day of Week\", fontsize=label_fontsize)\nfig.supylabel(\"Counts\", fontsize=label_fontsize)\n\n# crash.set_index('MONTH_NAME').loc[month_abbr_order].groupby(by=['MONTH_NAME']).agg({'PEDESTRIAN_CASUALTY_COUNT': 'sum'}).plot(kind='bar')\ncrash_casualty_data = create_grouped_casualty_data_by_category(\n    victim_categories, 'day_name', day_abbr_order)\ncrash_casualty_data\ncreate_bar_plots_for_casualty_data(\n    sns, axes, day_abbr_order, crash_casualty_data)\n\n\n\n\n\n\n\n\nThe hour between 5 and 6 pm is the worst time for human casualties, with 40,777 injuries and deaths. The rush-hour times around 5 pm have a high casualty count. The morning rush hour also trends higher, but much lower than the evening rush-hour.\nThe early hours of the morning between 12 and 1 am also having a high body count. This is at a time when you would expect the traffic volume to be low.\n\nCyclists - Follow the trend with 4,167 casualties between 5 and 6 pm.\nMotorists - Get off to an earlier start, with 28,142 casualties between 4 and 5 pm.\nPedestrians - Pedestrians get hit at higher rates between 5 and 6 pm, with 8,6623 casualties since the start of 2013.\n\n\n\nCode - Create Seaborn charts for crash casualties based on the Hour of day.\n#  Create the outer figure box\ncol_ct = 1\nfig, axes = plt.subplots(4, col_ct, figsize=(\n    15, 40), layout=\"constrained\", gridspec_kw=gridspec_kw)\n\nfig.suptitle(\"Total Hour of Day Crash Casualties from {0} to {1} by Category\".format(\n    start_date, end_date), fontsize=title_fontsize)\nfig.supxlabel(\"Hour of Day\", fontsize=label_fontsize)\nfig.supylabel(\"Counts\", fontsize=label_fontsize)\n\ncrash_casualty_data = create_grouped_casualty_data_by_category(\n    victim_categories, 'hour', hour_order)\n\n#  Create the inner charts\ncreate_bar_plots_for_casualty_data(\n    sns, axes, hour_order, crash_casualty_data)"
  },
  {
    "objectID": "crash_time_period_stats.html#print-out-the-column-names-before-and-after-they-are-renamed",
    "href": "crash_time_period_stats.html#print-out-the-column-names-before-and-after-they-are-renamed",
    "title": "NYC Collision Data Analysis",
    "section": "Print out the column names before and after they are renamed",
    "text": "Print out the column names before and after they are renamed\n\n\nRename Some of the Columns\noriginal_col_names = crash.columns.to_list()\n\n# Rename the columns using the list of new names, 'cols_rename'\ncrash.rename(columns=cols_rename, inplace=True)\n\nprint(\"Original Crash Column Names\\n{}\".format(original_col_names))\nprint(\"\\nRenamed Crash Columns Names\\n{}\".format(crash.columns.to_list()))\n\n\nOriginal Crash Column Names\n['CRASH DATE', 'CRASH TIME', 'BOROUGH', 'ZIP CODE', 'LOCATION', 'ON STREET NAME', 'CROSS STREET NAME', 'OFF STREET NAME', 'NUMBER OF PERSONS INJURED', 'NUMBER OF PERSONS KILLED', 'NUMBER OF PEDESTRIANS INJURED', 'NUMBER OF PEDESTRIANS KILLED', 'NUMBER OF CYCLIST INJURED', 'NUMBER OF CYCLIST KILLED', 'NUMBER OF MOTORIST INJURED', 'NUMBER OF MOTORIST KILLED']\n\nRenamed Crash Columns Names\n['DATE', 'TIME', 'BOROUGH', 'ZIP_CODE', 'LOCATION', 'ON_STREET_NAME', 'CROSS_STREET_NAME', 'OFF_STREET_NAME', 'NUM_PERSONS_INJURED', 'NUM_PERSONS_KILLED', 'NUM_PEDESTRIANS_INJURED', 'NUM_PEDESTRIANS_KILLED', 'NUM_CYCLISTS_INJURED', 'NUM_CYCLISTS_KILLED', 'NUM_MOTORISTS_INJURED', 'NUM_MOTORISTS_KILLED']\n\n\n\n# Ensure that the 'numeric_cols' column values are numeric and not string values\n\nconvert_to_numeric(crash, numeric_cols)\n\n\n\nCode - General Description of the dataset\n#  General Description of the dataset.\n\n# The 'set_option' is used here to display numeric values as a 'float' rather\n# than the default scientific notation\npd.set_option('display.float_format', lambda x: '%8.2f' % x)\ncrash.describe()\n\n\n\n\n\n\n\n\n\nNUM_PERSONS_INJURED\nNUM_PERSONS_KILLED\nNUM_PEDESTRIANS_INJURED\nNUM_PEDESTRIANS_KILLED\nNUM_CYCLISTS_INJURED\nNUM_CYCLISTS_KILLED\nNUM_MOTORISTS_INJURED\nNUM_MOTORISTS_KILLED\n\n\n\n\ncount\n2017370.00\n2017370.00\n2017370.00\n2017370.00\n2017370.00\n2017370.00\n2017370.00\n2017370.00\n\n\nmean\n0.30\n0.00\n0.06\n0.00\n0.03\n0.00\n0.22\n0.00\n\n\nstd\n0.69\n0.04\n0.24\n0.03\n0.16\n0.01\n0.65\n0.03\n\n\nmin\n0.00\n0.00\n0.00\n0.00\n0.00\n0.00\n0.00\n0.00\n\n\n25%\n0.00\n0.00\n0.00\n0.00\n0.00\n0.00\n0.00\n0.00\n\n\n50%\n0.00\n0.00\n0.00\n0.00\n0.00\n0.00\n0.00\n0.00\n\n\n75%\n0.00\n0.00\n0.00\n0.00\n0.00\n0.00\n0.00\n0.00\n\n\nmax\n43.00\n8.00\n27.00\n6.00\n4.00\n2.00\n43.00\n5.00\n\n\n\n\n\n\n\n\nMerge the ‘DATE’ and ‘TIME’ columns into one ‘DATE’ column.\nThe original ‘DATE’ is a “date only” field without the time. After merging the date and time columns, convert ‘DATE’ to a Python “datetime” object. Then remove the now unnecessary ‘TIME’ column.\n\n\nCode - Merge DATE and TIME into DATE\n# Merge\ncrash['DATE'] = pd.to_datetime(crash['DATE'] + \" \" + crash['TIME'])\n# Remove the 'TIME' column\ncrash.drop(columns=['TIME'], inplace=True)\n# Convert to Python 'datetime'\ncrash['DATE'] = pd.to_datetime(crash['DATE'])\n\n\n\ncrash['DATE'].describe()\n\ncount                          2017370\nmean     2017-05-13 17:54:54.650598912\nmin                2012-07-01 00:05:00\n25%                2014-12-19 13:00:15\n50%                2017-03-29 10:07:30\n75%                2019-06-09 17:50:00\nmax                2023-08-12 23:56:00\nName: DATE, dtype: object\n\n\n\nFrom the crash['DATE'].describe()\nWe can see that the first collision record (min) was on July 7, 2012 The last record (max), for this iteration is August 12, 2023.\n\n# Create a \"start_date\" and \"end_date\" variable, which is useful for our charts\n\nstart_date = crash['DATE'].dt.date.min()\nend_date = crash['DATE'].dt.date.max()\n\nprint(\"Start Date: {0} - End Date: {1}\".format(start_date, end_date))\n\nStart Date: 2012-07-01 - End Date: 2023-08-12\n\n\n\n\nThe ‘UNKNOWN’ Borough\nThe BOROUGH column contains the 5 boroughs of New York City, BROOKLYN, BRONX, MANHATTAN, QUEENS and STATEN ISLAND.\nUnfortunately, many of the ‘BOROUGH’ fields are empty.\nThe NYPD don’t record the borough in certain situations. For example, if the collision occurred on one of the main bridges between boroughs, or if the collision occurred on any one of NYC’s many expressways or parkways. Further investigation would be needed to confirm this.\nI previously reached out to the open data team for more information on this, but got no reply.\n\n# Replace empty 'BOROUGH' values with 'UNKNOWN'\n\ncrash.fillna(value={'BOROUGH': 'UNKNOWN'}, inplace=True)\ncrash['BOROUGH'].describe()\n\ncount     2017370\nunique          6\ntop       UNKNOWN\nfreq       627585\nName: BOROUGH, dtype: object\n\n\n\n\ncrash['BOROUGH'].describe() provides some useful information.\n\nunique\n\nUnique borough name count, which includes the ‘UNKNOWN’ borough\n\ntop\n\n‘UNKNOWN’ is the most frequent borough recorded\n\nfreq\n\nTells us the occurrence of ‘UNKNOWN’ borough records\n\ncount\n\nHow many rows of data in the dataset\n\n\n\n\nZIP_CODE\n\n# Replace empty ZIP_CODE's with 'UNKNOWN'\n\ncrash.fillna(value={'ZIP_CODE': 'UNKNOWN'}, inplace=True)\ncrash['ZIP_CODE'].describe()\n\ncount     2017370\nunique        235\ntop       UNKNOWN\nfreq       627823\nName: ZIP_CODE, dtype: object\n\n\n\ncrash['ZIP_CODE'].describe()\nAs with the BOROUGH column, the postal ZIP_CODE is often left empty. In this case, using crash['ZIP_CODE'].describe(), we see that the ZIP_CODE with the most collisions, top, is 11207 in Brooklyn.\nThe freq gives a count of collisions for this zip code. 11207 has a large population, almost 80,000 people, which may account for these numbers. A future project would be to see how these zip code counts relate to their population. The unique number tells us that there are 234 NYC zip codes with recorded collisions in this dataset.\n\n\n\nCreate some new columns YEAR, MONTH_NAME, DAY_NAME, HOUR\n\nby extracting information from the DATE column\n\n\n\nCode\n# Set up some date columns: YEAR, MONTH_NAME, DAY_NAME, HOUR\n# Remove all records for 2012 as it's only a partial year.\n\ncrash['YEAR'] = crash['DATE'].dt.year\n\n# Get rid of 2012 as it only has 6 months of data\nno_2012_mask = crash['YEAR'] &gt; 2012\ncrash = crash[no_2012_mask]\n\n# Reset the start_date variable to reflect the change\nstart_date = crash['DATE'].dt.date.min()\nyear_order = crash['YEAR'].sort_values().unique()\n\n# Create a MONTH_NAME column. Actually, month abbreviated name\ncrash['MONTH_NAME'] = crash['DATE'].dt.month_name().str[0:3]\n\n# Create a HOUR column, which reflects the hour of day that the collision occurred\ncrash['HOUR'] = crash['DATE'].dt.strftime(\"%H\")\n\n# Need to convert hour_order to a Python list instead of Numpy array\nhour_order = crash['HOUR'].sort_values().unique().tolist()\n\n\ncrash['DAY_NAME'] = crash['DATE'].dt.strftime(\"%a\")\n\nprint(\"Year, Month and Hour order lists will be used for charting.\")\nprint(\"Year order: {}\\n\".format(year_order))\nprint(\"Month abbreviations: {}\\n\".format(crash.MONTH_NAME.unique()))\nprint(\"Hour order: {}\\n\".format(hour_order))\n\n\nYear, Month and Hour order lists will be used for charting.\nYear order: [2013 2014 2015 2016 2017 2018 2019 2020 2021 2022 2023]\n\nMonth abbreviations: ['Sep' 'Mar' 'Jun' 'Dec' 'Apr' 'Jul' 'Feb' 'Aug' 'Nov' 'May' 'Jan' 'Oct']\n\nHour order: ['00', '01', '02', '03', '04', '05', '06', '07', '08', '09', '10', '11', '12', '13', '14', '15', '16', '17', '18', '19', '20', '21', '22', '23']\n\n\n\n\n\n\nThe Worst Years for Collision Injuries and Deaths\n\nChart the Yearly Collision Injuries and Deaths\n\nThis chart will give an overview of the total deaths and injuries on NYC roads.\n\n\n\nCode\n# Create a plot using Matplotlib with Yearly details on the number of people killed and injured\n\nkilled_injured = {\n    'Killed': crash_by_year_killed.loc[year_order], 'Injured': crash_by_year_injured.loc[year_order]}\n\nx = np.arange(len(year_order))  # the label locations\nwidth = 0.45  # the width of the bars\nmultiplier = 0\nfig, ax = plt.subplots(figsize=(10, 15), layout='constrained')\n\n# Create the Injured/Killed bars for each year\nfor killed_or_injured, count in killed_injured.items():\n    offset = width * multiplier\n    rects = ax.bar(x + offset, count, width, label=killed_or_injured)\n    ax.bar_label(rects, padding=3)\n    multiplier += 1\n\n# Add some text for labels, title and custom x-axis tick labels, etc.\nax.set_xlabel('Year', fontsize=14)\nax.set_ylabel('Killed/Injured Count', fontsize=14)\nax.set_title('Persons Killed and Injured From {0} to {1}'.format(\n    start_date, end_date), fontsize=20)\nax.set_xticks(x + (width/2), year_order)\nax.legend(loc='upper left')\nax.set_yscale('log')\nplt.show()\n\n\n\n\n\n\nCollision Injuries and Deaths since 2013\nThe chart shows that traffic fatalities had a general downward trend froom the high or 297 in 2013 to a low of 231 in 2018. The trend is upwards from 2019 to 2021, which was just 1 off the worst year, 2013. For injuries, 2016 to 2019 were the worst. The following years are a slight improvement, but no visible downward trend yet.\n\n\n\nCombine Killed + Injured Counts into one ‘CASUALTIES’ column\nFor each category, Person, Pedestrian, Cyclist and Motorist I’m going to combine the Killed/Injured counts into one ‘CASUALTY’ count.\n\n\nCode\n# Combine the INJURED and KILLED columns into one 'CASUALTIES' column.\n\ncrash['PERSON_CASUALTY_COUNT'] = crash.NUM_PERSONS_INJURED + \\\n    crash.NUM_PERSONS_KILLED\ncrash['PEDESTRIAN_CASUALTY_COUNT'] = crash.NUM_PEDESTRIANS_INJURED + \\\n    crash.NUM_PEDESTRIANS_KILLED\n\ncrash['CYCLIST_CASUALTY_COUNT'] = crash.NUM_CYCLISTS_INJURED + \\\n    crash.NUM_CYCLISTS_KILLED\ncrash['MOTORIST_CASUALTY_COUNT'] = crash.NUM_MOTORISTS_INJURED + \\\n    crash.NUM_MOTORISTS_KILLED\n\nkilled_injured_mask = (crash.NUM_PERSONS_KILLED &gt; 0) & (crash.NUM_PERSONS_INJURED &gt; 0)\n# Check that it looks good\ncrash[killed_injured_mask][['NUM_PERSONS_KILLED', 'NUM_PERSONS_INJURED',\n            'PERSON_CASUALTY_COUNT']]\n\n\n\n\n\n\n\n\n\nNUM_PERSONS_KILLED\nNUM_PERSONS_INJURED\nPERSON_CASUALTY_COUNT\n\n\nCOLLISION_ID\n\n\n\n\n\n\n\n4407693\n1\n4\n5\n\n\n4457151\n1\n1\n2\n\n\n4457192\n1\n2\n3\n\n\n4457191\n1\n3\n4\n\n\n4487497\n1\n1\n2\n\n\n...\n...\n...\n...\n\n\n4642411\n1\n2\n3\n\n\n4642632\n1\n1\n2\n\n\n4643193\n2\n4\n6\n\n\n4643448\n1\n2\n3\n\n\n4643896\n1\n3\n4\n\n\n\n\n666 rows × 3 columns\n\n\n\n\nFunction show_values\nA function to print count values above or to the side of chart bars.\nI got the original function from this useful site,statology.org.\nOriginal Fuction.\n\n\nCode\n# Prints value count above or to the side of barchart bars\ndef show_values(axs, orient=\"v\", space=.01):\n    def _single(ax):\n        if orient == \"v\":\n            for p in ax.patches:\n                _x = p.get_x() + p.get_width() / 2\n                _y = p.get_y() + p.get_height() + (p.get_height()*0.01)\n                value = '{:6,.0f}'.format(p.get_height())\n                ax.text(_x, _y, value, ha=\"center\", fontsize=12)\n        elif orient == \"h\":\n            for p in ax.patches:\n                _x = p.get_x() + p.get_width() + float(space)\n                _y = p.get_y() + p.get_height() - (p.get_height()*0.5)\n                value = '{:6,.0f}'.format(p.get_width())\n                ax.text(_x, _y, value, ha=\"left\", fontsize=12)\n\n    if isinstance(axs, np.ndarray):\n        for idx, ax in np.ndenumerate(axs):\n            _single(ax)\n    else:\n        _single(axs)\n\n\n\n\nHelper functions for creating multiple charts based on Grouped statistics\n\n\nCode\n# Statistics will be created for the below columns. \n#   PERSON_CASUALTY_COUNT\n#   PEDESTRIAN_CASUALTY_COUNT\n#   CYCLIST_CASUALTY_COUNT\n#   MOTORIST_CASUALTY_COUNT\n\ndef create_grouped_casualty_data_by_category(victim_categories, time_group=\"YEAR\", order_list=None):\n    ''' \n    Create multiple Seaborn SubPlot charts based on:\n    PERSON_CASUALTY_COUNT, PEDESTRIAN_CASUALTY_COUNT, CYCLIST_CASUALTY_COUNT and MOTORIST_CASUALTY_COUNT\n    time_group can be 'HOUR', 'DAY_OF_WEEK', 'MONTH_NAME', 'YEAR' \n    '''\n    time_group = time_group.upper()\n    all_casualty_data = []\n\n    for category in victim_categories:\n        cat_upper = category.upper()\n        casualty_label = cat_upper + '_CASUALTY_COUNT'\n\n        casualty_data = crash.groupby(\n            by=[time_group], as_index=True).agg({casualty_label: 'sum'})\n        if order_list and len(order_list):\n            casualty_data = casualty_data.loc[order_list]\n\n        category_data = {\n            'category': category,\n            'casualty_label': casualty_label,\n            'casualty_data':  casualty_data\n        }\n\n        all_casualty_data.append(category_data)\n    return all_casualty_data\n\n\ndef create_bar_plots_for_casualty_data(sns, axes, order_list, crash_victims_data):\n    for idx, category_data in enumerate(crash_victims_data):\n        xlabel = None\n        ylabel = None\n        # Casualty Chart\n        category_title = category_data['category'].title()\n        chart_title = \"{0} Casualties\".format(category_title)\n\n        casualty_max = category_data['casualty_data'][category_data['casualty_label']].max(\n        )\n        casualty_values = category_data['casualty_data'][category_data['casualty_label']].to_list(\n        )\n\n        casualty_colors = ['tab:gray' if (\n            x &gt;= casualty_max) else 'tab:red' for x in casualty_values]\n\n        ax = axes[idx]\n\n        sns.barplot(data=category_data['casualty_data'], x=order_list, order=order_list,\n                    y=category_data['casualty_label'], palette=casualty_colors, ax=ax).set(title=chart_title, xlabel=xlabel, ylabel=ylabel)\n\n        show_values(axes)\n\n\n\n# Set some global Matplotlib/Seaborn chart variables\ntitle_fontsize = 20\nlabel_fontsize = 18\n# For spacing between charts on the same grid\ngridspec_kw = {'wspace': 0.1, 'hspace': 0.1}\n\nsns.set_style(\"whitegrid\")\n\n\n# Plot charts for crash casualties based on the Year\n\ncol_ct = 1\n#  Create the outer figure box\nfig, axes = plt.subplots(4, col_ct, figsize=(\n    15, 40), layout=\"constrained\", gridspec_kw=gridspec_kw)\nfig.suptitle(\"Total Yearly Crash Casualties from {0} to {1} by Category\".format(\n    start_date, end_date), fontsize=title_fontsize)\nfig.supxlabel(\"Year\", fontsize=label_fontsize)\nfig.supylabel(\"Counts\", fontsize=label_fontsize)\n\ncrash_casualty_data = create_grouped_casualty_data_by_category(\n    victim_categories, 'year')\ncreate_bar_plots_for_casualty_data(\n    sns, axes, year_order, crash_casualty_data)\n\n\n\n\n\n''' Plot charts for crash casualties based on the Month'''\n\n#  Create the outer figure box\ncol_ct = 1\nfig, axes = plt.subplots(4, col_ct, figsize=(\n    20, 30), layout=\"constrained\", gridspec_kw=gridspec_kw)\n\nfig.suptitle(\"Total Monthly Crash Casualties from {0} to {1} by Category\".format(\n    start_date, end_date), fontsize=title_fontsize)\nfig.supxlabel(\"Month\", fontsize=label_fontsize)\nfig.supylabel(\"Counts\", fontsize=label_fontsize)\n\ncrash_casualty_data = create_grouped_casualty_data_by_category(\n    victim_categories, 'month_name', month_abbr_order)\ncreate_bar_plots_for_casualty_data(\n    sns, axes, month_abbr_order, crash_casualty_data)\n\n\n\n\n\n'''\nPlot Charts for Day of Week Statistics\n'''\ncol_ct = 1\nfig, axes = plt.subplots(4, col_ct, figsize=(\n    15, 40), layout=\"constrained\", gridspec_kw=gridspec_kw)\n\nfig.suptitle(\"Total Day of Week Crash Casualties from {0} to {1} by Category\".format(\n    start_date, end_date), fontsize=title_fontsize)\nfig.supxlabel(\"Day of Week\", fontsize=label_fontsize)\nfig.supylabel(\"Counts\", fontsize=label_fontsize)\n\n# crash.set_index('MONTH_NAME').loc[month_abbr_order].groupby(by=['MONTH_NAME']).agg({'PEDESTRIAN_CASUALTY_COUNT': 'sum'}).plot(kind='bar')\ncrash_casualty_data = create_grouped_casualty_data_by_category(\n    victim_categories, 'day_name', day_abbr_order)\ncrash_casualty_data\ncreate_bar_plots_for_casualty_data(\n    sns, axes, day_abbr_order, crash_casualty_data)\n\n\n\n\n\n''' Plot charts for crash casualties based on the Hour of Day'''\n\n#  Create the outer figure box\ncol_ct = 1\nfig, axes = plt.subplots(4, col_ct, figsize=(\n    15, 40), layout=\"constrained\", gridspec_kw=gridspec_kw)\n\nfig.suptitle(\"Total Hour of Day Crash Casualties from {0} to {1} by Category\".format(\n    start_date, end_date), fontsize=title_fontsize)\nfig.supxlabel(\"Hour of Day\", fontsize=label_fontsize)\nfig.supylabel(\"Counts\", fontsize=label_fontsize)\n\ncrash_casualty_data = create_grouped_casualty_data_by_category(\n    victim_categories, 'hour', hour_order)\n\n#  Create the inner charts\ncreate_bar_plots_for_casualty_data(\n    sns, axes, hour_order, crash_casualty_data)"
  },
  {
    "objectID": "test.html",
    "href": "test.html",
    "title": "NYC Collision Data Analysis",
    "section": "",
    "text": "# Import All Required Python Modules\n\nimport numpy as np\nimport pandas as pd\nimport datetime\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n\n\n# Data Formatting Functions\n\ndef empty_to_zero(val):\n    '''Converts empty values to 0'''\n    val = val.strip('\\s+')\n    return val if len(val) else 0\n\n\ndef convert_to_numeric(df, column_list):\n    '''Given a list of DataFrame columns, it converts the empty values to zero'''\n    df[column_list] = df[column_list].apply(pd.to_numeric, errors='coerce')\n\n\n# Set Up Some Global Variables\n\n# I'm omitting longitude, latitude, the vehicle types as well as crash contributing factors.\ncols_requested = ['COLLISION_ID', 'CRASH DATE', 'CRASH TIME', 'BOROUGH', 'ZIP CODE', 'LOCATION', 'ON STREET NAME', 'CROSS STREET NAME', 'OFF STREET NAME', 'NUMBER OF PERSONS INJURED',\n                  'NUMBER OF PERSONS KILLED', 'NUMBER OF PEDESTRIANS INJURED', 'NUMBER OF PEDESTRIANS KILLED', 'NUMBER OF CYCLIST INJURED', 'NUMBER OF CYCLIST KILLED', 'NUMBER OF MOTORIST INJURED', 'NUMBER OF MOTORIST KILLED']\n\n# To ensure that the colums are of the expected data type\ncrash_dtypes = {'CRASH DATE': str,\n                'CRASH TIME': str,\n                'BOROUGH': str,\n                'ZIP CODE': str,\n                'LOCATION': str,\n                'ON STREET NAME': str,\n                'CROSS STREET NAME': str,\n                'OFF STREET NAME': str,\n                }\n\n# Rename some colums to ones that I believe are shorter and/or more meaningful\ncols_rename = {'CRASH DATE': 'DATE',\n               'CRASH TIME': 'TIME',\n               'ZIP CODE': 'ZIP_CODE',\n               'ON STREET NAME': 'ON_STREET_NAME',\n               'CROSS STREET NAME': 'CROSS_STREET_NAME',\n               'OFF STREET NAME': 'OFF_STREET_NAME',\n               'NUMBER OF PERSONS INJURED': 'NUM_PERSONS_INJURED',\n               'NUMBER OF PERSONS KILLED': 'NUM_PERSONS_KILLED',\n               'NUMBER OF PEDESTRIANS INJURED': 'NUM_PEDESTRIANS_INJURED',\n               'NUMBER OF PEDESTRIANS KILLED': 'NUM_PEDESTRIANS_KILLED',\n               'NUMBER OF CYCLIST INJURED': 'NUM_CYCLISTS_INJURED',\n               'NUMBER OF CYCLIST KILLED': 'NUM_CYCLISTS_KILLED',\n               'NUMBER OF MOTORIST INJURED': 'NUM_MOTORISTS_INJURED',\n               'NUMBER OF MOTORIST KILLED': 'NUM_MOTORISTS_KILLED'\n               }\n\n# Columns that contain numeric values\nnumeric_cols = ['NUM_PERSONS_INJURED',\n                'NUM_PERSONS_KILLED',\n                'NUM_PEDESTRIANS_INJURED',\n                'NUM_PEDESTRIANS_KILLED',\n                'NUM_CYCLISTS_INJURED',\n                'NUM_CYCLISTS_KILLED',\n                'NUM_MOTORISTS_INJURED',\n                'NUM_MOTORISTS_KILLED']\n\n# These ordered lists are useful for plotting charts\nday_names_order = [\"Monday\", \"Tuesday\", \"Wednesday\",\n                   \"Thursday\", \"Friday\", \"Saturday\", \"Sunday\"]\nday_abbr_order = [d[0:3] for d in day_names_order]\nmonth_names_order = [\"January\", \"February\", \"March\", \"April\", \"May\",\n                     \"June\", \"July\", \"August\", \"September\", \"October\", \"November\", \"December\"]\nmonth_abbr_order = [m[0:3] for m in month_names_order]\n\n# The following DataFrame columns that will have their empty values converted to zero using the\n# 'empty_to_zero' function\nconvert_cols = {\n    'NUMBER OF PERSONS INJURED': empty_to_zero,\n    'NUMBER OF PERSONS KILLED':  empty_to_zero,\n    'NUMBER OF PEDESTRIANS INJURED': empty_to_zero,\n    'NUMBER OF PEDESTRIANS KILLED': empty_to_zero,\n    'NUMBER OF CYCLIST INJURED': empty_to_zero,\n    'NUMBER OF CYCLIST KILLED': empty_to_zero,\n    'NUMBER OF MOTORIST INJURED': empty_to_zero,\n    'NUMBER OF MOTORIST KILLED': empty_to_zero\n}\n\n# These are the 4 categories supplied by the NYPD\n# 'person' status should be a combination of the other three categories\n# TODO I need to verify the relationship between 'person' and the other three categories\nvictim_categories = ['person', 'cyclist', 'motorist', 'pedestrian']\n\n# These are the Matplotlib Tableau colors\nbar_colors = ['tab:blue', 'tab:orange', 'tab:green', 'tab:red',\n              'tab:purple', 'tab:brown', 'tab:pink', 'tab:gray', 'tab:olive', 'tab:cyan']\n\nbase_colors = ['b', 'g', 'r', 'c', 'm', 'y', 'k', 'w']\n\n# Chart Colors\ncolor = 'k'\nplt.rcParams['text.color'] = color\nplt.rcParams['axes.labelcolor'] = color\nplt.rcParams['xtick.color'] = 'b'\nplt.rcParams['ytick.color'] = 'b'\n\n\n\n\n\n\n# Using the Pandas 'read_csv' function\ncrash = pd.read_csv('../Motor_Vehicle_Collisions_Aug15_2023.csv',\n                    index_col='COLLISION_ID', usecols=cols_requested, dtype=crash_dtypes, converters=convert_cols)"
  },
  {
    "objectID": "test.html#focusing-on-casualty-statistics-over-different-time-periods",
    "href": "test.html#focusing-on-casualty-statistics-over-different-time-periods",
    "title": "NYC Collision Data Analysis",
    "section": "",
    "text": "# Import All Required Python Modules\n\nimport numpy as np\nimport pandas as pd\nimport datetime\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n\n\n# Data Formatting Functions\n\ndef empty_to_zero(val):\n    '''Converts empty values to 0'''\n    val = val.strip('\\s+')\n    return val if len(val) else 0\n\n\ndef convert_to_numeric(df, column_list):\n    '''Given a list of DataFrame columns, it converts the empty values to zero'''\n    df[column_list] = df[column_list].apply(pd.to_numeric, errors='coerce')\n\n\n# Set Up Some Global Variables\n\n# I'm omitting longitude, latitude, the vehicle types as well as crash contributing factors.\ncols_requested = ['COLLISION_ID', 'CRASH DATE', 'CRASH TIME', 'BOROUGH', 'ZIP CODE', 'LOCATION', 'ON STREET NAME', 'CROSS STREET NAME', 'OFF STREET NAME', 'NUMBER OF PERSONS INJURED',\n                  'NUMBER OF PERSONS KILLED', 'NUMBER OF PEDESTRIANS INJURED', 'NUMBER OF PEDESTRIANS KILLED', 'NUMBER OF CYCLIST INJURED', 'NUMBER OF CYCLIST KILLED', 'NUMBER OF MOTORIST INJURED', 'NUMBER OF MOTORIST KILLED']\n\n# To ensure that the colums are of the expected data type\ncrash_dtypes = {'CRASH DATE': str,\n                'CRASH TIME': str,\n                'BOROUGH': str,\n                'ZIP CODE': str,\n                'LOCATION': str,\n                'ON STREET NAME': str,\n                'CROSS STREET NAME': str,\n                'OFF STREET NAME': str,\n                }\n\n# Rename some colums to ones that I believe are shorter and/or more meaningful\ncols_rename = {'CRASH DATE': 'DATE',\n               'CRASH TIME': 'TIME',\n               'ZIP CODE': 'ZIP_CODE',\n               'ON STREET NAME': 'ON_STREET_NAME',\n               'CROSS STREET NAME': 'CROSS_STREET_NAME',\n               'OFF STREET NAME': 'OFF_STREET_NAME',\n               'NUMBER OF PERSONS INJURED': 'NUM_PERSONS_INJURED',\n               'NUMBER OF PERSONS KILLED': 'NUM_PERSONS_KILLED',\n               'NUMBER OF PEDESTRIANS INJURED': 'NUM_PEDESTRIANS_INJURED',\n               'NUMBER OF PEDESTRIANS KILLED': 'NUM_PEDESTRIANS_KILLED',\n               'NUMBER OF CYCLIST INJURED': 'NUM_CYCLISTS_INJURED',\n               'NUMBER OF CYCLIST KILLED': 'NUM_CYCLISTS_KILLED',\n               'NUMBER OF MOTORIST INJURED': 'NUM_MOTORISTS_INJURED',\n               'NUMBER OF MOTORIST KILLED': 'NUM_MOTORISTS_KILLED'\n               }\n\n# Columns that contain numeric values\nnumeric_cols = ['NUM_PERSONS_INJURED',\n                'NUM_PERSONS_KILLED',\n                'NUM_PEDESTRIANS_INJURED',\n                'NUM_PEDESTRIANS_KILLED',\n                'NUM_CYCLISTS_INJURED',\n                'NUM_CYCLISTS_KILLED',\n                'NUM_MOTORISTS_INJURED',\n                'NUM_MOTORISTS_KILLED']\n\n# These ordered lists are useful for plotting charts\nday_names_order = [\"Monday\", \"Tuesday\", \"Wednesday\",\n                   \"Thursday\", \"Friday\", \"Saturday\", \"Sunday\"]\nday_abbr_order = [d[0:3] for d in day_names_order]\nmonth_names_order = [\"January\", \"February\", \"March\", \"April\", \"May\",\n                     \"June\", \"July\", \"August\", \"September\", \"October\", \"November\", \"December\"]\nmonth_abbr_order = [m[0:3] for m in month_names_order]\n\n# The following DataFrame columns that will have their empty values converted to zero using the\n# 'empty_to_zero' function\nconvert_cols = {\n    'NUMBER OF PERSONS INJURED': empty_to_zero,\n    'NUMBER OF PERSONS KILLED':  empty_to_zero,\n    'NUMBER OF PEDESTRIANS INJURED': empty_to_zero,\n    'NUMBER OF PEDESTRIANS KILLED': empty_to_zero,\n    'NUMBER OF CYCLIST INJURED': empty_to_zero,\n    'NUMBER OF CYCLIST KILLED': empty_to_zero,\n    'NUMBER OF MOTORIST INJURED': empty_to_zero,\n    'NUMBER OF MOTORIST KILLED': empty_to_zero\n}\n\n# These are the 4 categories supplied by the NYPD\n# 'person' status should be a combination of the other three categories\n# TODO I need to verify the relationship between 'person' and the other three categories\nvictim_categories = ['person', 'cyclist', 'motorist', 'pedestrian']\n\n# These are the Matplotlib Tableau colors\nbar_colors = ['tab:blue', 'tab:orange', 'tab:green', 'tab:red',\n              'tab:purple', 'tab:brown', 'tab:pink', 'tab:gray', 'tab:olive', 'tab:cyan']\n\nbase_colors = ['b', 'g', 'r', 'c', 'm', 'y', 'k', 'w']\n\n# Chart Colors\ncolor = 'k'\nplt.rcParams['text.color'] = color\nplt.rcParams['axes.labelcolor'] = color\nplt.rcParams['xtick.color'] = 'b'\nplt.rcParams['ytick.color'] = 'b'\n\n\n\n\n\n\n# Using the Pandas 'read_csv' function\ncrash = pd.read_csv('../Motor_Vehicle_Collisions_Aug15_2023.csv',\n                    index_col='COLLISION_ID', usecols=cols_requested, dtype=crash_dtypes, converters=convert_cols)"
  },
  {
    "objectID": "test.html#print-out-the-column-names-before-and-after-they-are-renamed",
    "href": "test.html#print-out-the-column-names-before-and-after-they-are-renamed",
    "title": "NYC Collision Data Analysis",
    "section": "Print out the column names before and after they are renamed",
    "text": "Print out the column names before and after they are renamed\n\noriginal_col_names = crash.columns.to_list()\nprint(\"Original Crash Column Names\")\nprint(original_col_names)\n\n# Rename the columns using the list of new names, 'cols_rename'\ncrash.rename(columns=cols_rename, inplace=True)\n\nprint(\"Renamed Crash Columns Names\")\nprint(crash.columns.to_list())\n\nOriginal Crash Column Names\n['CRASH DATE', 'CRASH TIME', 'BOROUGH', 'ZIP CODE', 'LOCATION', 'ON STREET NAME', 'CROSS STREET NAME', 'OFF STREET NAME', 'NUMBER OF PERSONS INJURED', 'NUMBER OF PERSONS KILLED', 'NUMBER OF PEDESTRIANS INJURED', 'NUMBER OF PEDESTRIANS KILLED', 'NUMBER OF CYCLIST INJURED', 'NUMBER OF CYCLIST KILLED', 'NUMBER OF MOTORIST INJURED', 'NUMBER OF MOTORIST KILLED']\nRenamed Crash Columns Names\n['DATE', 'TIME', 'BOROUGH', 'ZIP_CODE', 'LOCATION', 'ON_STREET_NAME', 'CROSS_STREET_NAME', 'OFF_STREET_NAME', 'NUM_PERSONS_INJURED', 'NUM_PERSONS_KILLED', 'NUM_PEDESTRIANS_INJURED', 'NUM_PEDESTRIANS_KILLED', 'NUM_CYCLISTS_INJURED', 'NUM_CYCLISTS_KILLED', 'NUM_MOTORISTS_INJURED', 'NUM_MOTORISTS_KILLED']\n\n\n\n# Ensure that the 'numeric_cols' column values are numeric and not string values\n\nconvert_to_numeric(crash, numeric_cols)\n\n\n#  General Description of the dataset.\n\n# The 'set_option' is uesed here to display numeric values as a 'float' rather\n# than the default scientific notation\npd.set_option('display.float_format', lambda x: '%8.2f' % x)\ncrash.describe()\n\n\n\n\n\n\n\n\nNUM_PERSONS_INJURED\nNUM_PERSONS_KILLED\nNUM_PEDESTRIANS_INJURED\nNUM_PEDESTRIANS_KILLED\nNUM_CYCLISTS_INJURED\nNUM_CYCLISTS_KILLED\nNUM_MOTORISTS_INJURED\nNUM_MOTORISTS_KILLED\n\n\n\n\ncount\n2017370.00\n2017370.00\n2017370.00\n2017370.00\n2017370.00\n2017370.00\n2017370.00\n2017370.00\n\n\nmean\n0.30\n0.00\n0.06\n0.00\n0.03\n0.00\n0.22\n0.00\n\n\nstd\n0.69\n0.04\n0.24\n0.03\n0.16\n0.01\n0.65\n0.03\n\n\nmin\n0.00\n0.00\n0.00\n0.00\n0.00\n0.00\n0.00\n0.00\n\n\n25%\n0.00\n0.00\n0.00\n0.00\n0.00\n0.00\n0.00\n0.00\n\n\n50%\n0.00\n0.00\n0.00\n0.00\n0.00\n0.00\n0.00\n0.00\n\n\n75%\n0.00\n0.00\n0.00\n0.00\n0.00\n0.00\n0.00\n0.00\n\n\nmax\n43.00\n8.00\n27.00\n6.00\n4.00\n2.00\n43.00\n5.00\n\n\n\n\n\n\n\n\nMerge the ‘DATE’ and ‘TIME’ columns into one ‘DATE’ column.\nThe original ‘DATE’ is a “date only” field without the time. After merging the date and time columns, convert ‘DATE’ to a Python “datetime” object. Then remove the now unnecessary ‘TIME’ column.\n\n# Merge\ncrash['DATE'] = pd.to_datetime(crash['DATE'] + \" \" + crash['TIME'])\n# Remove the 'TIME' column\ncrash.drop(columns=['TIME'], inplace=True)\n# Convert to Python 'datetime'\ncrash['DATE'] = pd.to_datetime(crash['DATE'])\n\n\ncrash['DATE'].describe()\n\ncount                          2017370\nmean     2017-05-13 17:54:54.650598912\nmin                2012-07-01 00:05:00\n25%                2014-12-19 13:00:15\n50%                2017-03-29 10:07:30\n75%                2019-06-09 17:50:00\nmax                2023-08-12 23:56:00\nName: DATE, dtype: object\n\n\n\nFrom the crash['DATE'].describe()\nWe can see that the first collision record (min) was on July 7, 2012 The last record (max), for this iteration is August 12, 2023.\n\n# Create a \"start_date\" and \"end_date\" variable, which is useful for our charts\n\nstart_date = crash['DATE'].dt.date.min()\nend_date = crash['DATE'].dt.date.max()\n\nprint(\"Start Date: {0} - End Date: {1}\".format(start_date, end_date))\n\nStart Date: 2012-07-01 - End Date: 2023-08-12\n\n\n\n\nThe ‘UNKNOWN’ Borough\nThe BOROUGH column contains the 5 boroughs of New York City, BROOKLYN, BRONX, MANHATTAN, QUEENS and STATEN ISLAND.\nUnfortunately, many of the ‘BOROUGH’ fields are empty.\nThe NYPD don’t record the borough in certain situations. For example, if the collision occurred on one of the main bridges between boroughs, or if the collision occurred on any one of NYC’s many expressways or parkways. Further investigation would be needed to confirm this.\nI previously reached out to the open data team for more information on this, but got no reply.\n\n# Replace empty 'BOROUGH' values with 'UNKNOWN'\n\ncrash.fillna(value={'BOROUGH': 'UNKNOWN'}, inplace=True)\ncrash['BOROUGH'].describe()\n\ncount     2017370\nunique          6\ntop       UNKNOWN\nfreq       627585\nName: BOROUGH, dtype: object\n\n\n\n\ncrash['BOROUGH'].describe() provides some useful information.\n\nunique\n\nUnique borough name count, which includes the ‘UNKNOWN’ borough\n\ntop\n\n‘UNKNOWN’ is the most frequent borough recorded\n\nfreq\n\nTells us the occurrence of ‘UNKNOWN’ borough records\n\ncount\n\nHow many rows of data in the dataset\n\n\n\n# Another check to see the unique borough names\n\ncrash['BOROUGH'].unique()\n\narray(['UNKNOWN', 'BROOKLYN', 'BRONX', 'MANHATTAN', 'QUEENS',\n       'STATEN ISLAND'], dtype=object)\n\n\n\n\nZIP_CODE\nAs with the BOROUGH column, the postal ZIP_CODE is often left empty. In this case, using crash['ZIP_CODE'].describe(), we see that the ZIP_CODE with the most collisions, top, is 11207 in Brooklyn. The freq gives a count of collisions for this zip code. It has a pretty large population, almost 80,000 people, which may account for the large numbers. A future project would be to see how these zip code counts relate to their population. The unique number tells us that there are 234 NYC zip codes with recorded collisions.\nCheck out zip code, 11207 here.\n\ncrash['ZIP_CODE'].describe()\n\ncount     1389547\nunique        234\ntop         11207\nfreq        26853\nName: ZIP_CODE, dtype: object\n\n\n\n# Replace empty ZIP_CODE's with 'UNKNOWN'\n\ncrash.fillna(value={'ZIP_CODE': 'UNKNOWN'}, inplace=True)\ncrash['ZIP_CODE'].head()\n\nCOLLISION_ID\n4455765    UNKNOWN\n4513547    UNKNOWN\n4541903    UNKNOWN\n4456314      11208\n4486609      11233\nName: ZIP_CODE, dtype: object\n\n\n\n\nCode\n# Set up some date columns: YEAR, MONTH_NAME, DAY_NAME, HOUR\n# and remove any records for 2012\n\ncrash['YEAR'] = crash['DATE'].dt.year\n\n# Get rid of 2012 as it only has 6 months of data\nno_2012_mask = crash['YEAR'] &gt; 2012\ncrash = crash[no_2012_mask]\n\n# Reset the start_date variable to reflect the change\nstart_date = crash['DATE'].dt.date.min()\nyear_order = crash['YEAR'].sort_values().unique()\nprint(\"Year order: {}\".format(year_order))\n\n# Create a MONTH_NAME column. Actually, month abbreviated name\ncrash['MONTH_NAME'] = crash['DATE'].dt.month_name().str[0:3]\nprint(\"Month abbreviations: {}\".format(crash.MONTH_NAME.unique()))\n\n# Create a HOUR column, which reflects the hour of day that the collision occurred\ncrash['HOUR'] = crash['DATE'].dt.strftime(\"%H\")\n\n# Need to convert hour_order to a Python list instead of Numpy array\nhour_order = crash['HOUR'].sort_values().unique().tolist()\n\nprint(\"Hour order: {}\".format(hour_order))\n\ncrash['DAY_NAME'] = crash['DATE'].dt.strftime(\"%a\")\n\n\nYear order: [2013 2014 2015 2016 2017 2018 2019 2020 2021 2022 2023]\nMonth abbreviations: ['Sep' 'Mar' 'Jun' 'Dec' 'Apr' 'Jul' 'Feb' 'Aug' 'Nov' 'May' 'Jan' 'Oct']\nHour order: ['00', '01', '02', '03', '04', '05', '06', '07', '08', '09', '10', '11', '12', '13', '14', '15', '16', '17', '18', '19', '20', '21', '22', '23']\n\n\n\n\nThe Worst Years for Collision Injuries and Deaths\n\n\nCode\n# Get the Yearly Killed/Injured counts\n\ncrash_by_year_killed = crash.groupby(\n    'YEAR')['NUM_PERSONS_KILLED'].sum().sort_values(ascending=False)\ncrash_by_year_injured = crash.groupby(\n    'YEAR')['NUM_PERSONS_INJURED'].sum().sort_values(ascending=False)\n\nprint(\"5 Worst Years for Collision Deaths\")\nprint(crash_by_year_killed.head(5))\nprint(\"\\n5 Worst Years for Collision Injuries\")\nprint(crash_by_year_injured.head(5))\n\n\n5 Worst Years for Collision Deaths\nYEAR\n2013    297\n2021    296\n2022    287\n2020    269\n2014    262\nName: NUM_PERSONS_KILLED, dtype: int64\n\n5 Worst Years for Collision Injuries\nYEAR\n2018    61941\n2019    61389\n2017    60656\n2016    60317\n2013    55124\nName: NUM_PERSONS_INJURED, dtype: int64\n\n\n\n\nChart the Yearly Collisin Injuries and Deaths\n\n\nCode\n# Create a plot using Matplotlib with Yearly details on the number of people killed and injured\n\nkilled_injured = {\n    'Killed': crash_by_year_killed.loc[year_order], 'Injured': crash_by_year_injured.loc[year_order]}\n\nx = np.arange(len(year_order))  # the label locations\nwidth = 0.45  # the width of the bars\nmultiplier = 0\nfig, ax = plt.subplots(figsize=(10, 15), layout='constrained')\n\n# Create the Injured/Killed bars for each year\nfor killed_or_injured, count in killed_injured.items():\n    offset = width * multiplier\n    rects = ax.bar(x + offset, count, width, label=killed_or_injured)\n    ax.bar_label(rects, padding=3)\n    multiplier += 1\n\n# Add some text for labels, title and custom x-axis tick labels, etc.\nax.set_xlabel('Year', fontsize=14)\nax.set_ylabel('Killed/Injured Count', fontsize=14)\nax.set_title('Persons Killed and Injured From {0} to {1}'.format(\n    start_date, end_date), fontsize=20)\nax.set_xticks(x + (width/2), year_order)\nax.legend(loc='upper left')\nax.set_yscale('log')\nplt.show()\n\n\n\n\n\n\nCollision Injuries and Deaths since 2013\nThe chart shows that traffic fatalities had a general downward trend froom the high or 297 in 2013 to a low of 231 in 2018. The trend is upwards from 2019 to 2021, which was just 1 off the worst year, 2013. For injuries, 2016 to 2019 were the worst. The following years are a slight improvement, but no visible downward trend yet.\n\n\n\nCombine Killed + Injured Counts into one ‘CASUALTIES’ column\nFor each category, Person, Pedestrian, Cyclist and Motorist I’m going to combine the Killed/Injured counts into one ‘CASUALTY’ count.\n\n# Combine the INJURED and KILLED columns into one 'CASUALTIES' column.\ncrash['PERSON_CASUALTY_COUNT'] = crash.NUM_PERSONS_INJURED + \\\n    crash.NUM_PERSONS_KILLED\ncrash['PEDESTRIAN_CASUALTY_COUNT'] = crash.NUM_PEDESTRIANS_INJURED + \\\n    crash.NUM_PEDESTRIANS_KILLED\ncrash['CYCLIST_CASUALTY_COUNT'] = crash.NUM_CYCLISTS_INJURED + \\\n    crash.NUM_CYCLISTS_KILLED\ncrash['MOTORIST_CASUALTY_COUNT'] = crash.NUM_MOTORISTS_INJURED + \\\n    crash.NUM_MOTORISTS_KILLED\ncrash.head(60)\n\nkmm = (crash.NUM_PERSONS_KILLED &gt; 0) & (crash.NUM_PERSONS_INJURED &gt; 0)\n# Check that it looks good\ncrash[kmm][['NUM_PERSONS_KILLED', 'NUM_PERSONS_INJURED',\n            'PERSON_CASUALTY_COUNT']].head()\n\n\n\n\n\n\n\n\nNUM_PERSONS_KILLED\nNUM_PERSONS_INJURED\nPERSON_CASUALTY_COUNT\n\n\nCOLLISION_ID\n\n\n\n\n\n\n\n4407693\n1\n4\n5\n\n\n4457151\n1\n1\n2\n\n\n4457192\n1\n2\n3\n\n\n4457191\n1\n3\n4\n\n\n4487497\n1\n1\n2\n\n\n\n\n\n\n\n\n'''\nFunction to print count values above or to the side of chart bars\nI got the original function from this useful site, https://www.statology.org\nOriginal Fuction: https://www.statology.org/seaborn-barplot-show-values/\n'''\n\n\ndef show_values(axs, orient=\"v\", space=.01):\n    def _single(ax):\n        if orient == \"v\":\n            for p in ax.patches:\n                _x = p.get_x() + p.get_width() / 2\n                _y = p.get_y() + p.get_height() + (p.get_height()*0.01)\n                value = '{:6,.0f}'.format(p.get_height())\n                ax.text(_x, _y, value, ha=\"center\", fontsize=12)\n        elif orient == \"h\":\n            for p in ax.patches:\n                _x = p.get_x() + p.get_width() + float(space)\n                _y = p.get_y() + p.get_height() - (p.get_height()*0.5)\n                value = '{:6,.0f}'.format(p.get_width())\n                ax.text(_x, _y, value, ha=\"left\", fontsize=12)\n\n    if isinstance(axs, np.ndarray):\n        for idx, ax in np.ndenumerate(axs):\n            _single(ax)\n    else:\n        _single(axs)\n\n\n'''\nHelper functions for creating multiple charts based on Grouped statistics\nGrouped time periods can be 'HOUR', 'MONTH', 'YEAR', 'DAY_NAME'\n\nStatistics will be created for the below columns. \n    PERSON_CASUALTY_COUNT\n    PEDESTRIAN_CASUALTY_COUNT\n    CYCLIST_CASUALTY_COUNT\n    MOTORIST_CASUALTY_COUNT\n'''\n\n\ndef create_grouped_casualty_data_by_category(victim_categories, time_group=\"YEAR\", order_list=None):\n    ''' \n    time_group can be 'HOUR', 'DAY_OF_WEEK', 'MONTH', 'YEAR' \n    '''\n    time_group = time_group.upper()\n    all_casualty_data = []\n\n    for category in victim_categories:\n        cat_upper = category.upper()\n        casualty_label = cat_upper + '_CASUALTY_COUNT'\n\n        casualty_data = crash.groupby(\n            by=[time_group], as_index=True).agg({casualty_label: 'sum'})\n        if order_list and len(order_list):\n            casualty_data = casualty_data.loc[order_list]\n\n        category_data = {\n            'category': category,\n            'casualty_label': casualty_label,\n            'casualty_data':  casualty_data\n        }\n\n        all_casualty_data.append(category_data)\n    return all_casualty_data\n\n\ndef create_bar_plots_for_casualty_data(sns, axes, order_list, crash_victims_data):\n    for idx, category_data in enumerate(crash_victims_data):\n        xlabel = None\n        ylabel = None\n        # Casualty Chart\n        category_title = category_data['category'].title()\n        chart_title = \"{0} Casualties\".format(category_title)\n\n        casualty_max = category_data['casualty_data'][category_data['casualty_label']].max(\n        )\n        casualty_values = category_data['casualty_data'][category_data['casualty_label']].to_list(\n        )\n\n        casualty_colors = ['tab:gray' if (\n            x &gt;= casualty_max) else 'tab:red' for x in casualty_values]\n\n        ax = axes[idx]\n\n        sns.barplot(data=category_data['casualty_data'], x=order_list, order=order_list,\n                    y=category_data['casualty_label'], palette=casualty_colors, ax=ax).set(title=chart_title, xlabel=xlabel, ylabel=ylabel)\n\n        show_values(axes)\n\n\n'''\nSet some global chart variables\n'''\ntitle_fontsize = 20\nlabel_fontsize = 18\n# For spacing between charts on one grid\ngridspec_kw = {'wspace': 0.1, 'hspace': 0.1}\n\nsns.set_style(\"whitegrid\")\n\n\n''' Plot charts for crash casualties based on the Year'''\n\ncol_ct = 1\n#  Create the outer figure box\nfig, axes = plt.subplots(4, col_ct, figsize=(\n    15, 40), layout=\"constrained\", gridspec_kw=gridspec_kw)\nfig.suptitle(\"Total Yearly Crash Casualties from {0} to {1} by Category\".format(\n    start_date, end_date), fontsize=title_fontsize)\nfig.supxlabel(\"Year\", fontsize=label_fontsize)\nfig.supylabel(\"Counts\", fontsize=label_fontsize)\n\n\ncrash_casualty_data = create_grouped_casualty_data_by_category(\n    victim_categories, 'year')\ncreate_bar_plots_for_casualty_data(\n    sns, axes, year_order, crash_casualty_data)\n\n\n\n\n\n''' Plot charts for crash casualties based on the Month'''\n\n#  Create the outer figure box\ncol_ct = 1\nfig, axes = plt.subplots(4, col_ct, figsize=(\n    20, 30), layout=\"constrained\", gridspec_kw=gridspec_kw)\n\nfig.suptitle(\"Total Monthly Crash Casualties from {0} to {1} by Category\".format(\n    start_date, end_date), fontsize=title_fontsize)\nfig.supxlabel(\"Month\", fontsize=label_fontsize)\nfig.supylabel(\"Counts\", fontsize=label_fontsize)\n\ncrash_casualty_data = create_grouped_casualty_data_by_category(\n    victim_categories, 'month_name', month_abbr_order)\ncreate_bar_plots_for_casualty_data(\n    sns, axes, month_abbr_order, crash_casualty_data)\n\n\n\n\n\n'''\nPlot Charts for Day of Week Statistics\n'''\ncol_ct = 1\nfig, axes = plt.subplots(4, col_ct, figsize=(\n    15, 40), layout=\"constrained\", gridspec_kw=gridspec_kw)\n\nfig.suptitle(\"Total Day of Week Crash Casualties from {0} to {1} by Category\".format(\n    start_date, end_date), fontsize=title_fontsize)\nfig.supxlabel(\"Day of Week\", fontsize=label_fontsize)\nfig.supylabel(\"Counts\", fontsize=label_fontsize)\n\n# crash.set_index('MONTH_NAME').loc[month_abbr_order].groupby(by=['MONTH_NAME']).agg({'PEDESTRIAN_CASUALTY_COUNT': 'sum'}).plot(kind='bar')\ncrash_casualty_data = create_grouped_casualty_data_by_category(\n    victim_categories, 'day_name', day_abbr_order)\ncrash_casualty_data\ncreate_bar_plots_for_casualty_data(\n    sns, axes, day_abbr_order, crash_casualty_data)\n\n\n\n\n\n''' Plot charts for crash casualties based on the Hour of Day'''\n\n#  Create the outer figure box\ncol_ct = 1\nfig, axes = plt.subplots(4, col_ct, figsize=(\n    15, 40), layout=\"constrained\", gridspec_kw=gridspec_kw)\n\nfig.suptitle(\"Total Hour of Day Crash Casualties from {0} to {1} by Category\".format(\n    start_date, end_date), fontsize=title_fontsize)\nfig.supxlabel(\"Hour of Day\", fontsize=label_fontsize)\nfig.supylabel(\"Counts\", fontsize=label_fontsize)\n\ncrash_casualty_data = create_grouped_casualty_data_by_category(\n    victim_categories, 'hour', hour_order)\n\n#  Create the inner charts\ncreate_bar_plots_for_casualty_data(\n    sns, axes, hour_order, crash_casualty_data)\n\n\n\n\n\ncrash.groupby(by=['YEAR']).agg({'NUM_CYCLISTS_KILLED': 'sum', 'NUM_CYCLISTS_INJURED': 'sum'}).sort_values(\n    by=['NUM_CYCLISTS_KILLED', 'NUM_CYCLISTS_INJURED'], ascending=False)\n\n\n\n\n\n\n\n\nNUM_CYCLISTS_KILLED\nNUM_CYCLISTS_INJURED\n\n\nYEAR\n\n\n\n\n\n\n2019\n31\n4986\n\n\n2020\n29\n5576\n\n\n2017\n27\n4889\n\n\n2023\n21\n2977\n\n\n2014\n20\n4000\n\n\n2022\n19\n5026\n\n\n2021\n19\n4961\n\n\n2016\n18\n4975\n\n\n2015\n15\n4281\n\n\n2013\n11\n4075\n\n\n2018\n10\n4725\n\n\n\n\n\n\n\n\n# hide\ncrash.groupby(by=['YEAR']).agg({'NUM_PEDESTRIANS_KILLED': 'sum', 'NUM_PEDESTRIANS_INJURED': 'sum'}).sort_values(\n    by=['NUM_PEDESTRIANS_INJURED', 'NUM_PEDESTRIANS_KILLED'], ascending=False)\n# by=['NUM_PEDESTRIANS_KILLED', 'NUM_PEDESTRIANS_INJURED'], ascending=False)\n\n\n\n\n\n\n\n\nNUM_PEDESTRIANS_KILLED\nNUM_PEDESTRIANS_INJURED\n\n\nYEAR\n\n\n\n\n\n\n2013\n176\n11988\n\n\n2017\n127\n11151\n\n\n2018\n123\n11123\n\n\n2016\n149\n11090\n\n\n2014\n133\n11036\n\n\n2019\n131\n10568\n\n\n2015\n133\n10084\n\n\n2022\n132\n8975\n\n\n2021\n131\n7501\n\n\n2020\n101\n6691\n\n\n2023\n53\n5199\n\n\n\n\n\n\n\n\nkilled_ped_month_group = crash.groupby(by=['MONTH_NAME']).agg({'NUM_PEDESTRIANS_KILLED': 'sum'}).sort_values(\n    by=['NUM_PEDESTRIANS_KILLED'], ascending=False)\nkilled_ped_month_group.head()\n\n\n\n\n\n\n\n\nNUM_PEDESTRIANS_KILLED\n\n\nMONTH_NAME\n\n\n\n\n\nNov\n151\n\n\nOct\n138\n\n\nDec\n136\n\n\nJan\n123\n\n\nSep\n117\n\n\n\n\n\n\n\n\ninjured_ped_month_group = crash.groupby(by=['MONTH_NAME']).agg({'NUM_PEDESTRIANS_INJURED': 'sum'}).sort_values(\n    by=['NUM_PEDESTRIANS_INJURED'], ascending=False)\ninjured_ped_month_group.head()\n\n\n\n\n\n\n\n\nNUM_PEDESTRIANS_INJURED\n\n\nMONTH_NAME\n\n\n\n\n\nDec\n10614\n\n\nJan\n10133\n\n\nNov\n9576\n\n\nOct\n9553\n\n\nMar\n9079\n\n\n\n\n\n\n\n\nkilled_cyc_month_group = crash.groupby(by=['MONTH_NAME']).agg({'NUM_CYCLISTS_KILLED': 'sum'}).sort_values(\n    by=['NUM_CYCLISTS_KILLED'], ascending=False)\nkilled_cyc_month_group.head()\n\n\n\n\n\n\n\n\nNUM_CYCLISTS_KILLED\n\n\nMONTH_NAME\n\n\n\n\n\nJun\n36\n\n\nJul\n26\n\n\nSep\n25\n\n\nAug\n20\n\n\nMay\n20\n\n\n\n\n\n\n\n\nkilled_mot_month_group = crash.groupby(\n    'MONTH_NAME')['NUM_MOTORISTS_KILLED'].sum().sort_values(ascending=False)\nkilled_mot_month_group.head(12)\n\nMONTH_NAME\nJul    131\nJun    126\nAug    124\nMay    108\nSep    104\nApr     93\nNov     86\nOct     81\nJan     73\nDec     72\nFeb     67\nMar     66\nName: NUM_MOTORISTS_KILLED, dtype: int64\n\n\n\ninnjured_mot_month_group = crash.groupby(\n    'MONTH_NAME')['NUM_MOTORISTS_INJURED'].sum().sort_values(ascending=False)\ninnjured_mot_month_group.head(12)\n\nMONTH_NAME\nJul    41009\nJun    40883\nMay    39722\nAug    38051\nSep    35934\nOct    35172\nApr    33746\nMar    33482\nNov    32447\nDec    31690\nJan    30270\nFeb    27842\nName: NUM_MOTORISTS_INJURED, dtype: int64\n\n\n\nkilled_injured_by_zip = crash.groupby(by=['ZIP_CODE']).agg({'NUM_PERSONS_KILLED': 'sum', 'NUM_PERSONS_INJURED': 'sum'}).sort_values(\n    by=['NUM_PERSONS_KILLED', 'NUM_PERSONS_INJURED'], ascending=False)\ninjured_killed_by_zip = crash.groupby(by=['ZIP_CODE']).agg({'NUM_PERSONS_KILLED': 'sum', 'NUM_PERSONS_INJURED': 'sum'}).sort_values(\n    by=['NUM_PERSONS_INJURED', 'NUM_PERSONS_KILLED'], ascending=False)\nprint(\"     5 Worst zip codes for crash deaths.\")\nprint(killed_injured_by_zip.head(5))\nprint(\"     5 Worst zip codes for crash injuries.\")\nprint(injured_killed_by_zip.head(5))\n\n     5 Worst zip codes for crash deaths.\n          NUM_PERSONS_KILLED  NUM_PERSONS_INJURED\nZIP_CODE                                         \nUNKNOWN                 1145               205507\n11236                     45                 7482\n11207                     32                 9956\n11234                     28                 5460\n11208                     25                 6044\n     5 Worst zip codes for crash injuries.\n          NUM_PERSONS_KILLED  NUM_PERSONS_INJURED\nZIP_CODE                                         \nUNKNOWN                 1145               205507\n11207                     32                 9956\n11236                     45                 7482\n11203                     13                 7367\n11212                     17                 6631"
  },
  {
    "objectID": "crash_time_period_stats.html#focusing-on-casualty-statistics-over-different-time-periods-1",
    "href": "crash_time_period_stats.html#focusing-on-casualty-statistics-over-different-time-periods-1",
    "title": "NYC Collision Data Analysis",
    "section": "Focusing on casualty statistics over different time periods",
    "text": "Focusing on casualty statistics over different time periods\n\n# Import All Required Python Modules\n\nimport numpy as np\nimport pandas as pd\nimport datetime\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nfrom pathlib import Path\n\n\n# Data Formatting Functions\n\ndef empty_to_zero(val):\n    '''Converts empty values to 0'''\n    val = val.strip('\\s+')\n    return val if len(val) else 0\n\n\ndef convert_to_numeric(df, column_list):\n    '''Given a list of DataFrame columns, it converts the empty values to zero'''\n    df[column_list] = df[column_list].apply(pd.to_numeric, errors='coerce')\n\nprint(Path.cwd())\n\n/home/austin/Apps/nyc/crash_stats/nbs\n\n\n\n# Set Up Some Global Variables\n\n# I'm omitting longitude, latitude, the vehicle types as well as crash contributing factors.\ncols_requested = ['COLLISION_ID', 'CRASH DATE', 'CRASH TIME', 'BOROUGH', 'ZIP CODE', 'LOCATION', 'ON STREET NAME', 'CROSS STREET NAME', 'OFF STREET NAME', 'NUMBER OF PERSONS INJURED',\n                  'NUMBER OF PERSONS KILLED', 'NUMBER OF PEDESTRIANS INJURED', 'NUMBER OF PEDESTRIANS KILLED', 'NUMBER OF CYCLIST INJURED', 'NUMBER OF CYCLIST KILLED', 'NUMBER OF MOTORIST INJURED', 'NUMBER OF MOTORIST KILLED']\n\n# To ensure that the colums are of the expected data type\ncrash_dtypes = {'CRASH DATE': str,\n                'CRASH TIME': str,\n                'BOROUGH': str,\n                'ZIP CODE': str,\n                'LOCATION': str,\n                'ON STREET NAME': str,\n                'CROSS STREET NAME': str,\n                'OFF STREET NAME': str,\n                }\n\n# Rename some colums to ones that I believe are shorter and/or more meaningful\ncols_rename = {'CRASH DATE': 'DATE',\n               'CRASH TIME': 'TIME',\n               'ZIP CODE': 'ZIP_CODE',\n               'ON STREET NAME': 'ON_STREET_NAME',\n               'CROSS STREET NAME': 'CROSS_STREET_NAME',\n               'OFF STREET NAME': 'OFF_STREET_NAME',\n               'NUMBER OF PERSONS INJURED': 'NUM_PERSONS_INJURED',\n               'NUMBER OF PERSONS KILLED': 'NUM_PERSONS_KILLED',\n               'NUMBER OF PEDESTRIANS INJURED': 'NUM_PEDESTRIANS_INJURED',\n               'NUMBER OF PEDESTRIANS KILLED': 'NUM_PEDESTRIANS_KILLED',\n               'NUMBER OF CYCLIST INJURED': 'NUM_CYCLISTS_INJURED',\n               'NUMBER OF CYCLIST KILLED': 'NUM_CYCLISTS_KILLED',\n               'NUMBER OF MOTORIST INJURED': 'NUM_MOTORISTS_INJURED',\n               'NUMBER OF MOTORIST KILLED': 'NUM_MOTORISTS_KILLED'\n               }\n\n# Columns that contain numeric values\nnumeric_cols = ['NUM_PERSONS_INJURED',\n                'NUM_PERSONS_KILLED',\n                'NUM_PEDESTRIANS_INJURED',\n                'NUM_PEDESTRIANS_KILLED',\n                'NUM_CYCLISTS_INJURED',\n                'NUM_CYCLISTS_KILLED',\n                'NUM_MOTORISTS_INJURED',\n                'NUM_MOTORISTS_KILLED']\n\n# These ordered lists are useful for plotting charts\nday_names_order = [\"Monday\", \"Tuesday\", \"Wednesday\",\n                   \"Thursday\", \"Friday\", \"Saturday\", \"Sunday\"]\nday_abbr_order = [d[0:3] for d in day_names_order]\nmonth_names_order = [\"January\", \"February\", \"March\", \"April\", \"May\",\n                     \"June\", \"July\", \"August\", \"September\", \"October\", \"November\", \"December\"]\nmonth_abbr_order = [m[0:3] for m in month_names_order]\n\n# The following DataFrame columns that will have their empty values converted to zero using the\n# 'empty_to_zero' function\nconvert_cols = {\n    'NUMBER OF PERSONS INJURED': empty_to_zero,\n    'NUMBER OF PERSONS KILLED':  empty_to_zero,\n    'NUMBER OF PEDESTRIANS INJURED': empty_to_zero,\n    'NUMBER OF PEDESTRIANS KILLED': empty_to_zero,\n    'NUMBER OF CYCLIST INJURED': empty_to_zero,\n    'NUMBER OF CYCLIST KILLED': empty_to_zero,\n    'NUMBER OF MOTORIST INJURED': empty_to_zero,\n    'NUMBER OF MOTORIST KILLED': empty_to_zero\n}\n\n# These are the 4 categories supplied by the NYPD\n# 'person' status should be a combination of the other three categories\n# TODO I need to verify the relationship between 'person' and the other three categories\nvictim_categories = ['person', 'cyclist', 'motorist', 'pedestrian']\n\n# These are the Matplotlib Tableau colors\nbar_colors = ['tab:blue', 'tab:orange', 'tab:green', 'tab:red',\n              'tab:purple', 'tab:brown', 'tab:pink', 'tab:gray', 'tab:olive', 'tab:cyan']\n\nbase_colors = ['b', 'g', 'r', 'c', 'm', 'y', 'k', 'w']\n\n# Chart Colors\ncolor = 'k'\nplt.rcParams['text.color'] = color\nplt.rcParams['axes.labelcolor'] = color\nplt.rcParams['xtick.color'] = 'b'\nplt.rcParams['ytick.color'] = 'b'\n\n\nRead the NYC collision data CSV file.\n\nThe Collision Dataset provided by NYPD is available here.\n\n# Using the Pandas 'read_csv' function\n\ncollision_filename = \"Motor_Vehicle_Collisions_Aug15_2023.csv\"\n\ncrash = pd.read_csv(Path.cwd().joinpath(\"..\").joinpath(collision_filename),\n                    index_col='COLLISION_ID', usecols=cols_requested, dtype=crash_dtypes, converters=convert_cols)"
  },
  {
    "objectID": "crash_time_period_stats.html#focusing-on-new-york-city-casualty-statistics-over-different-time-periods-1",
    "href": "crash_time_period_stats.html#focusing-on-new-york-city-casualty-statistics-over-different-time-periods-1",
    "title": "NYC Collision Data Analysis",
    "section": "Focusing on New York City casualty statistics over different time periods",
    "text": "Focusing on New York City casualty statistics over different time periods\n\nWhat day of the week?\n...what time of day? \n...what month of the year? \nhas the most traffic collision related human casualties in New York City?  \nUsing the open traffic collisions data available from NYPD.\nYou can skip the explanations and go straight to the results.\nOr, you can read on and see how I came up with these numbers using Python and the pandas library.\n\n\nCode - Import All Required Python Modules\n# Import All Required Python Modules\nimport numpy as np\nimport pandas as pd\nimport datetime\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nfrom pathlib import Path\n\n\n\n\nCode - Data Formatting Functions\n# Data Formatting Functions\n\ndef empty_to_zero(val):\n    '''Converts empty values to 0'''\n    val = val.strip('\\s+')\n    return val if len(val) else 0\n\n\ndef convert_to_numeric(df, column_list):\n    '''Given a list of DataFrame columns, it converts the empty values to zero'''\n    df[column_list] = df[column_list].apply(pd.to_numeric, errors='coerce')\n\n\n\n\nCode - Set Up Some Global Variables\n# Set Up Some Global Variables\n\n# I'm omitting longitude, latitude, the vehicle types as well as crash contributing factors.\ncols_requested = ['COLLISION_ID', 'CRASH DATE', 'CRASH TIME', 'BOROUGH', 'ZIP CODE', 'LOCATION', 'ON STREET NAME', 'CROSS STREET NAME', 'OFF STREET NAME', 'NUMBER OF PERSONS INJURED',\n                  'NUMBER OF PERSONS KILLED', 'NUMBER OF PEDESTRIANS INJURED', 'NUMBER OF PEDESTRIANS KILLED', 'NUMBER OF CYCLIST INJURED', 'NUMBER OF CYCLIST KILLED', 'NUMBER OF MOTORIST INJURED', 'NUMBER OF MOTORIST KILLED']\n\n# To ensure that the colums are of the expected data type\ncrash_dtypes = {'CRASH DATE': str,\n                'CRASH TIME': str,\n                'BOROUGH': str,\n                'ZIP CODE': str,\n                'LOCATION': str,\n                'ON STREET NAME': str,\n                'CROSS STREET NAME': str,\n                'OFF STREET NAME': str,\n                }\n\n# Rename some colums to ones that I believe are shorter and/or more meaningful\ncols_rename = {'CRASH DATE': 'DATE',\n               'CRASH TIME': 'TIME',\n               'ZIP CODE': 'ZIP_CODE',\n               'ON STREET NAME': 'ON_STREET_NAME',\n               'CROSS STREET NAME': 'CROSS_STREET_NAME',\n               'OFF STREET NAME': 'OFF_STREET_NAME',\n               'NUMBER OF PERSONS INJURED': 'NUM_PERSONS_INJURED',\n               'NUMBER OF PERSONS KILLED': 'NUM_PERSONS_KILLED',\n               'NUMBER OF PEDESTRIANS INJURED': 'NUM_PEDESTRIANS_INJURED',\n               'NUMBER OF PEDESTRIANS KILLED': 'NUM_PEDESTRIANS_KILLED',\n               'NUMBER OF CYCLIST INJURED': 'NUM_CYCLISTS_INJURED',\n               'NUMBER OF CYCLIST KILLED': 'NUM_CYCLISTS_KILLED',\n               'NUMBER OF MOTORIST INJURED': 'NUM_MOTORISTS_INJURED',\n               'NUMBER OF MOTORIST KILLED': 'NUM_MOTORISTS_KILLED'\n               }\n\n# Columns that contain numeric values\nnumeric_cols = ['NUM_PERSONS_INJURED',\n                'NUM_PERSONS_KILLED',\n                'NUM_PEDESTRIANS_INJURED',\n                'NUM_PEDESTRIANS_KILLED',\n                'NUM_CYCLISTS_INJURED',\n                'NUM_CYCLISTS_KILLED',\n                'NUM_MOTORISTS_INJURED',\n                'NUM_MOTORISTS_KILLED']\n\n# These ordered lists are useful for plotting charts\nday_names_order = [\"Monday\", \"Tuesday\", \"Wednesday\",\n                   \"Thursday\", \"Friday\", \"Saturday\", \"Sunday\"]\nday_abbr_order = [d[0:3] for d in day_names_order]\nmonth_names_order = [\"January\", \"February\", \"March\", \"April\", \"May\",\n                     \"June\", \"July\", \"August\", \"September\", \"October\", \"November\", \"December\"]\nmonth_abbr_order = [m[0:3] for m in month_names_order]\n\n# The following DataFrame columns that will have their empty values converted to zero using the\n# 'empty_to_zero' function\nconvert_cols = {\n    'NUMBER OF PERSONS INJURED': empty_to_zero,\n    'NUMBER OF PERSONS KILLED':  empty_to_zero,\n    'NUMBER OF PEDESTRIANS INJURED': empty_to_zero,\n    'NUMBER OF PEDESTRIANS KILLED': empty_to_zero,\n    'NUMBER OF CYCLIST INJURED': empty_to_zero,\n    'NUMBER OF CYCLIST KILLED': empty_to_zero,\n    'NUMBER OF MOTORIST INJURED': empty_to_zero,\n    'NUMBER OF MOTORIST KILLED': empty_to_zero\n}\n\n# These are the 4 categories supplied by the NYPD\nvictim_categories = ['person', 'cyclist', 'motorist', 'pedestrian']\n# 'person' status should be a combination of the other three categories\n# TODO I need to verify the relationship between 'person' and the other three categories\n\n# These are the Matplotlib Tableau colors\nbar_colors = ['tab:blue', 'tab:orange', 'tab:green', 'tab:red',\n              'tab:purple', 'tab:brown', 'tab:pink', 'tab:gray', 'tab:olive', 'tab:cyan']\n\nbase_colors = ['b', 'g', 'r', 'c', 'm', 'y', 'k', 'w']\n\n# Chart Colors\ncolor = 'k'\nplt.rcParams['text.color'] = color\nplt.rcParams['axes.labelcolor'] = color\nplt.rcParams['xtick.color'] = 'b'\nplt.rcParams['ytick.color'] = 'b'\n\n\n\nRead the NYC collision data CSV file into our Pandas DataFrame, ‘crash’.\n\nThe Collision Dataset provided by NYPD is available here.\n\n\n\nCode - Creating the ‘crash’ DataFrame from the NYPD CSV file.\ncollision_filename = \"Motor_Vehicle_Collisions_Aug15_2023.csv\"\n\n# Using the Pandas 'read_csv' function\ncrash = pd.read_csv(Path.cwd().joinpath(\"..\").joinpath(collision_filename),\n                    index_col='COLLISION_ID', usecols=cols_requested, dtype=crash_dtypes, converters=convert_cols)\n\n\n\n\nRename some of the DataFrame columns\noriginal_col_names = crash.columns.to_list()\n\n# Rename the columns using the list of new names, 'cols_rename'\ncrash.rename(columns=cols_rename, inplace=True)\n\nprint(\"Original Crash Column Names\\n{}\".format(original_col_names))\nprint(\"\\nRenamed Crash Columns Names\\n{}\".format(crash.columns.to_list()))\n\n\nOriginal Crash Column Names\n['CRASH DATE', 'CRASH TIME', 'BOROUGH', 'ZIP CODE', 'LOCATION', 'ON STREET NAME', 'CROSS STREET NAME', 'OFF STREET NAME', 'NUMBER OF PERSONS INJURED', 'NUMBER OF PERSONS KILLED', 'NUMBER OF PEDESTRIANS INJURED', 'NUMBER OF PEDESTRIANS KILLED', 'NUMBER OF CYCLIST INJURED', 'NUMBER OF CYCLIST KILLED', 'NUMBER OF MOTORIST INJURED', 'NUMBER OF MOTORIST KILLED']\n\nRenamed Crash Columns Names\n['DATE', 'TIME', 'BOROUGH', 'ZIP_CODE', 'LOCATION', 'ON_STREET_NAME', 'CROSS_STREET_NAME', 'OFF_STREET_NAME', 'NUM_PERSONS_INJURED', 'NUM_PERSONS_KILLED', 'NUM_PEDESTRIANS_INJURED', 'NUM_PEDESTRIANS_KILLED', 'NUM_CYCLISTS_INJURED', 'NUM_CYCLISTS_KILLED', 'NUM_MOTORISTS_INJURED', 'NUM_MOTORISTS_KILLED']\n\n\n\n\nCode - Convert string values to numeric for specific ‘numeric’ columns.\n# Ensure that the 'numeric_cols' column values are numeric and not string values\nconvert_to_numeric(crash, numeric_cols)\n\n\n\n\nCode - General Description of the ‘crash’ dataset\n#  General Description of the dataset.\n\n# The 'set_option' is used here to display numeric values as a 'float' rather\n# than the default scientific notation\npd.set_option('display.float_format', lambda x: '%8.2f' % x)\ncrash.describe()\n\n\n\n\n\n\n\n\n\nNUM_PERSONS_INJURED\nNUM_PERSONS_KILLED\nNUM_PEDESTRIANS_INJURED\nNUM_PEDESTRIANS_KILLED\nNUM_CYCLISTS_INJURED\nNUM_CYCLISTS_KILLED\nNUM_MOTORISTS_INJURED\nNUM_MOTORISTS_KILLED\n\n\n\n\ncount\n2017370.00\n2017370.00\n2017370.00\n2017370.00\n2017370.00\n2017370.00\n2017370.00\n2017370.00\n\n\nmean\n0.30\n0.00\n0.06\n0.00\n0.03\n0.00\n0.22\n0.00\n\n\nstd\n0.69\n0.04\n0.24\n0.03\n0.16\n0.01\n0.65\n0.03\n\n\nmin\n0.00\n0.00\n0.00\n0.00\n0.00\n0.00\n0.00\n0.00\n\n\n25%\n0.00\n0.00\n0.00\n0.00\n0.00\n0.00\n0.00\n0.00\n\n\n50%\n0.00\n0.00\n0.00\n0.00\n0.00\n0.00\n0.00\n0.00\n\n\n75%\n0.00\n0.00\n0.00\n0.00\n0.00\n0.00\n0.00\n0.00\n\n\nmax\n43.00\n8.00\n27.00\n6.00\n4.00\n2.00\n43.00\n5.00\n\n\n\n\n\n\n\n\n\ncrash.describe()\nThe count tells us that there are over 2M rows of data. The maximum(max) NUM_PERSONS_INJURED in one collision is 43.\nThe average(mean) NUM_PERSONS_INJURED per collision is 0.3, or almost 1 for every three collisions. You can find more details on the pandas.DataFrame.describe function here.\n\n\nMerge the ‘DATE’ and ‘TIME’ columns into one ‘DATE’ column.\n\nThe original ‘DATE’ is a “date only” field without the time. After merging the date and time columns, convert ‘DATE’ to a Python “datetime” object. Then remove the now unnecessary ‘TIME’ column.\n\n\n\nCode - Combine the DATE and TIME columns into the DATE column\n# Merge\ncrash['DATE'] = pd.to_datetime(crash['DATE'] + \" \" + crash['TIME'])\n# Remove the 'TIME' column\ncrash.drop(columns=['TIME'], inplace=True)\n# Convert to Python 'datetime'\ncrash['DATE'] = pd.to_datetime(crash['DATE'])\n\n\n\ncrash['DATE'].describe()\n\ncount                          2017370\nmean     2017-05-13 17:54:54.650598912\nmin                2012-07-01 00:05:00\n25%                2014-12-19 13:00:15\n50%                2017-03-29 10:07:30\n75%                2019-06-09 17:50:00\nmax                2023-08-12 23:56:00\nName: DATE, dtype: object\n\n\n\n\ncrash['DATE'].describe()\nWe can see that the first collision record (min) was on July 8, 2012 The last record (max), for this iteration is August 12, 2023.\n\n\nCode - Create a ‘start_date’ and an ‘end_date’ variable.\n# Create a 'start_date' and 'end_date' variable, which is useful for our charts\nstart_date = crash['DATE'].dt.date.min()\nend_date = crash['DATE'].dt.date.max()\n\nprint(\"Start Date: {0} - End Date: {1}\".format(start_date, end_date))\n\n\nStart Date: 2012-07-01 - End Date: 2023-08-12\n\n\n\n\nThe ‘UNKNOWN’ Borough\nThe BOROUGH column contains the 5 boroughs of New York City, BROOKLYN, BRONX, MANHATTAN, QUEENS and STATEN ISLAND.\nUnfortunately, many of the ‘BOROUGH’ fields are empty.\nThe NYPD don’t record the borough in certain situations. For example, if the collision occurred on one of the main bridges between boroughs, or if the collision occurred on any one of NYC’s many expressways or parkways. Further investigation would be needed to confirm this.\nI previously reached out to the open data team for more information on this, but got no reply.\n\n\nCode - Replace empty ‘BOROUGH’ values with ‘UNKNOWN’\ncrash.fillna(value={'BOROUGH': 'UNKNOWN'}, inplace=True)\ncrash['BOROUGH'].describe()\n\n\ncount     2017370\nunique          6\ntop       UNKNOWN\nfreq       627585\nName: BOROUGH, dtype: object\n\n\n\n\ncrash['BOROUGH'].describe() provides some useful information.\n\nunique\n\nUnique borough name count, which includes the ‘UNKNOWN’ borough\n\ntop\n\n‘UNKNOWN’ is the most frequent borough recorded\n\nfreq\n\nTells us the occurrence of ‘UNKNOWN’ borough records\n\ncount\n\nHow many rows of data in the dataset\n\n\n\n\nZIP_CODE\n\n\nCode - Replace empty ZIP_CODE’s with ‘UNKNOWN’\n# Replace empty ZIP_CODE's with 'UNKNOWN'\ncrash.fillna(value={'ZIP_CODE': 'UNKNOWN'}, inplace=True)\ncrash['ZIP_CODE'].describe()\n\n\ncount     2017370\nunique        235\ntop       UNKNOWN\nfreq       627823\nName: ZIP_CODE, dtype: object\n\n\n\n\ncrash['ZIP_CODE'].describe()\nAs with the BOROUGH column, the postal ZIP_CODE is often left empty. In this case, using crash['ZIP_CODE'].describe(), we see that the ZIP_CODE with the most collisions, top, is 11207 in Brooklyn.\nThe freq gives a count of collisions for this zip code. 11207 has a large population, almost 80,000 people, which may account for these numbers. A future project would be to see how these zip code counts relate to their population. The unique number tells us that there are 234 NYC zip codes with recorded collisions in this dataset.\n\n\nCreate some new columns, YEAR, MONTH_NAME, DAY_NAME and HOUR\n\n\nCode - Create new columns, YEAR, MONTH_NAME, DAY_NAME and HOUR\n#  by extracting information from the *DATE* column\n\n# Set up some date columns: YEAR, MONTH_NAME, DAY_NAME, HOUR\n# Remove all records for 2012 as it's only a partial year.\n\ncrash['YEAR'] = crash['DATE'].dt.year\n\n# Get rid of 2012 as it only has 6 months of data\nno_2012_mask = crash['YEAR'] &gt; 2012\ncrash = crash[no_2012_mask]\n\n# Reset the start_date variable to reflect the change\nstart_date = crash['DATE'].dt.date.min()\nyear_order = crash['YEAR'].sort_values().unique()\n\n# Create a MONTH_NAME column. Actually, month abbreviated name\ncrash['MONTH_NAME'] = crash['DATE'].dt.month_name().str[0:3]\n\n# Create a HOUR column, which reflects the hour of day that the collision occurred\ncrash['HOUR'] = crash['DATE'].dt.strftime(\"%H\")\n\n# Need to convert hour_order to a Python list instead of Numpy array\nhour_order = crash['HOUR'].sort_values().unique().tolist()\n\ncrash['DAY_NAME'] = crash['DATE'].dt.strftime(\"%a\")\n\nprint(\"Year, Month and Hour order lists will be used for charting.\")\nprint(\"Year order: {}\\n\".format(year_order))\nprint(\"Month abbreviations: {}\\n\".format(crash.MONTH_NAME.unique()))\nprint(\"Hour order: {}\\n\".format(hour_order))\n\n\nYear, Month and Hour order lists will be used for charting.\nYear order: [2013 2014 2015 2016 2017 2018 2019 2020 2021 2022 2023]\n\nMonth abbreviations: ['Sep' 'Mar' 'Jun' 'Dec' 'Apr' 'Jul' 'Feb' 'Aug' 'Nov' 'May' 'Jan' 'Oct']\n\nHour order: ['00', '01', '02', '03', '04', '05', '06', '07', '08', '09', '10', '11', '12', '13', '14', '15', '16', '17', '18', '19', '20', '21', '22', '23']\n\n\n\n\n\nChart the Yearly Collision Injuries and Deaths\n\nThis chart will give an overview of the total deaths and injuries on NYC roads.\n\n\n\nCode - Create the yearly Killed/Injured collections.\ncrash_by_year_killed = crash.groupby(\n    'YEAR')['NUM_PERSONS_KILLED'].sum().sort_values(ascending=False)\ncrash_by_year_injured = crash.groupby(\n    'YEAR')['NUM_PERSONS_INJURED'].sum().sort_values(ascending=False)\n\n\n\n\nCode - Create Matplotlib bar chart with yearly details on the number of people killed and injured.\nkilled_injured = {\n    'Killed': crash_by_year_killed.loc[year_order], 'Injured': crash_by_year_injured.loc[year_order]}\n\nx_loc = np.arange(len(year_order))  # the label locations\nwidth = 0.45  # the width of the bars\nmultiplier = 0\nfig, ax = plt.subplots(figsize=(10, 15), layout='constrained')\n\n# Create the Injured/Killed bars for each year\nfor killed_or_injured, count in killed_injured.items():\n    offset = width * multiplier\n    rects = ax.bar(x_loc + offset, count, width, label=killed_or_injured)\n    ax.bar_label(rects, padding=3)\n    multiplier += 1\n\n# Add some text for labels, title and custom x-axis tick labels, etc.\nax.set_xlabel('Year', fontsize=14)\nax.set_ylabel('Killed/Injured Count', fontsize=14)\nax.set_title('Persons Killed and Injured From {0} to {1}'.format(\n    start_date, end_date), fontsize=20)\nax.set_xticks(x_loc + (width/2), year_order)\nax.legend(loc='upper left')\nax.set_yscale('log')\nplt.show()\n\n\n\n\n\n\nCollision Injuries and Deaths since 2013\nThe chart shows that traffic fatalities had a general downward trend from the high of 297 in 2013 to a low of 231 in 2018. The trend is upwards from 2019 to 2021, which was just 1 off the worst year, 2013. For injuries, 2016 to 2019 were the worst. The following years are a slight improvement, but no visible downward trend yet.\n\n\nCombine Killed + Injured Counts into one ‘CASUALTIES’ column\n\nFor each category, Person, Pedestrian, Cyclist and Motorist there will be a new ‘CASUALTY’ column with the combined Injured/Killed values\nThe new columns are, PERSON_CASUALTY_COUNT, PEDESTRIAN_CASUALTY_COUNT, CYCLIST_CASUALTY_COUNT and MOTORIST_CASUALTY_COUNT\n\n\n\nCode - Combine the INJURED and KILLED columns into one ‘CASUALTIES’ column.\ncrash['PERSON_CASUALTY_COUNT'] = crash.NUM_PERSONS_INJURED + \\\n    crash.NUM_PERSONS_KILLED\ncrash['PEDESTRIAN_CASUALTY_COUNT'] = crash.NUM_PEDESTRIANS_INJURED + \\\n    crash.NUM_PEDESTRIANS_KILLED\n\ncrash['CYCLIST_CASUALTY_COUNT'] = crash.NUM_CYCLISTS_INJURED + \\\n    crash.NUM_CYCLISTS_KILLED\ncrash['MOTORIST_CASUALTY_COUNT'] = crash.NUM_MOTORISTS_INJURED + \\\n    crash.NUM_MOTORISTS_KILLED\n\nkilled_injured_mask = (crash.NUM_PERSONS_KILLED &gt; 0) & (\n    crash.NUM_PERSONS_INJURED &gt; 0)\n\n\n\n\nFunction show_values\n\nA function to print value counts above or to the side of Barchart bars.\nI got the original function from this very useful site, statology.org.\nThe original function is here.\n\n\n\nCode - Function to print value counts above or to the side of barchart bars\ndef show_values(axs, orient=\"v\", space=.01):\n    def _single(ax):\n        if orient == \"v\":\n            for p in ax.patches:\n                _x = p.get_x() + p.get_width() / 2\n                _y = p.get_y() + p.get_height() + (p.get_height()*0.01)\n                value = '{:6,.0f}'.format(p.get_height())\n                ax.text(_x, _y, value, ha=\"center\", fontsize=12)\n        elif orient == \"h\":\n            for p in ax.patches:\n                _x = p.get_x() + p.get_width() + float(space)\n                _y = p.get_y() + p.get_height() - (p.get_height()*0.5)\n                value = '{:6,.0f}'.format(p.get_width())\n                ax.text(_x, _y, value, ha=\"left\", fontsize=12)\n\n    if isinstance(axs, np.ndarray):\n        for idx, ax in np.ndenumerate(axs):\n            _single(ax)\n    else:\n        _single(axs)\n\n\n\n\nCode - Helper functions for creating multiple charts based on Grouped statistics.\n# Statistics will be created for the below columns.\n#   PERSON_CASUALTY_COUNT\n#   PEDESTRIAN_CASUALTY_COUNT\n#   CYCLIST_CASUALTY_COUNT\n#   MOTORIST_CASUALTY_COUNT\n\ndef create_grouped_casualty_data_by_category(victim_categories, time_group=\"YEAR\", order_list=None):\n    ''' \n    Create multiple Seaborn SubPlot charts based on:\n    PERSON_CASUALTY_COUNT, PEDESTRIAN_CASUALTY_COUNT, CYCLIST_CASUALTY_COUNT and MOTORIST_CASUALTY_COUNT\n    time_group can be 'HOUR', 'DAY_OF_WEEK', 'MONTH_NAME', 'YEAR' \n    '''\n    time_group = time_group.upper()\n    all_casualty_data = []\n\n    for category in victim_categories:\n        cat_upper = category.upper()\n        casualty_label = cat_upper + '_CASUALTY_COUNT'\n\n        casualty_data = crash.groupby(\n            by=[time_group], as_index=True).agg({casualty_label: 'sum'})\n        if order_list and len(order_list):\n            casualty_data = casualty_data.loc[order_list]\n\n        category_data = {\n            'category': category,\n            'casualty_label': casualty_label,\n            'casualty_data':  casualty_data\n        }\n\n        all_casualty_data.append(category_data)\n    return all_casualty_data\n\n\ndef create_bar_plots_for_casualty_data(sns, axes, order_list, crash_victims_data):\n    for idx, category_data in enumerate(crash_victims_data):\n        xlabel = None\n        ylabel = None\n        # Casualty Chart\n        category_title = category_data['category'].title()\n        chart_title = \"{0} Casualties\".format(category_title)\n\n        casualty_max = category_data['casualty_data'][category_data['casualty_label']].max(\n        )\n        casualty_values = category_data['casualty_data'][category_data['casualty_label']].to_list(\n        )\n\n        casualty_colors = ['k' if (\n            x &gt;= casualty_max) else 'tab:red' for x in casualty_values]\n\n        ax = axes[idx]\n\n        sns.barplot(data=category_data['casualty_data'], x=order_list, order=order_list,\n                    y=category_data['casualty_label'], palette=casualty_colors, ax=ax).set(title=chart_title, xlabel=xlabel, ylabel=ylabel)\n\n        show_values(axes)\n\n\n\n\nCode - Set some global Matplotlib/Seaborn chart variables.\ntitle_fontsize = 20\nlabel_fontsize = 18\n# For spacing between charts on the same grid\ngridspec_kw = {'wspace': 0.1, 'hspace': 0.1}\n\nsns.set_style(\"whitegrid\")\n\n\n\n\n\n\nWhat was the worst year for traffic collision casualties?\n2018 was the worst for human casualties, with 62,172 injuries and deaths. 2019 was a close second, followed by 2017 and 2016.\n\nCyclists - 2020 was by far the worst year with 5,605 casualties.\nMotorists - 2018 was their worst year with 46,168 casualties.\nPedestrians - 2013 was their worst year with 12,164 casualties. Things have improved a little for them since then.\n\n\n\nCode - Create Seaborn charts for crash casualties based on year.\ncol_ct = 1\n#  Create the outer figure box\nfig, axes = plt.subplots(4, col_ct, figsize=(\n    15, 40), layout=\"constrained\", gridspec_kw=gridspec_kw)\nfig.suptitle(\"Total Yearly Crash Casualties from {0} to {1} by Category\".format(\n    start_date, end_date), fontsize=title_fontsize)\nfig.supxlabel(\"Year\", fontsize=label_fontsize)\nfig.supylabel(\"Counts\", fontsize=label_fontsize)\n\ncrash_casualty_data = create_grouped_casualty_data_by_category(\n    victim_categories, 'year')\ncreate_bar_plots_for_casualty_data(\n    sns, axes, year_order, crash_casualty_data)\n\n\n\n\n\n\n\nWhat are the worst months for traffic collision casualties?\nJune has been the worst month for human casualties, with 56,240 injuries and deaths.\nThe Summer months in general seem to be bad for motorists and cyclists, while winter is bad for pedestrians.\n\nCyclists - July has been the worst, with 6,270 casualties. August and June follow after that.\nMotorists - July has been the worst, with 41,140 casualties. June is a close second.\nPedestrians - December has been the worst, with 10,750 casualties. January is a close second.\n\nWinter time may be a good time to stay on public transport or indoors.\n\n\n\n\nCode - Create Seaborn charts for crash casualties based on month.\n# Create the outer figure box\ncol_ct = 1\nfig, axes = plt.subplots(4, col_ct, figsize=(\n    20, 30), layout=\"constrained\", gridspec_kw=gridspec_kw)\n\nfig.suptitle(\"Total Monthly Crash Casualties from {0} to {1} by Category\".format(\n    start_date, end_date), fontsize=title_fontsize)\nfig.supxlabel(\"Month\", fontsize=label_fontsize)\nfig.supylabel(\"Counts\", fontsize=label_fontsize)\n\ncrash_casualty_data = create_grouped_casualty_data_by_category(\n    victim_categories, 'month_name', month_abbr_order)\ncreate_bar_plots_for_casualty_data(\n    sns, axes, month_abbr_order, crash_casualty_data)\n\n\n\n\n\n\n\nWhat day of the week should you avoid going out?\nFriday tends to be the worst day for human casualties, with 90,089 injuries and deaths. Sunday seems to be the safest.\n\nCyclists - Friday is a bad day to bike in NYC, with 8,008 casualties since the start of 2013.\nMotorists - Friday and Saturday are equally bad, with 63,774 casualties each.\nPedestrians - Pedestrians should also avoid Fridays, with 17,337 casualties since the start of 2013.\n\n\n\nCode - Create Seaborn charts for crash casualties based on day of the week.\ncol_ct = 1\nfig, axes = plt.subplots(4, col_ct, figsize=(\n    15, 40), layout=\"constrained\", gridspec_kw=gridspec_kw)\n\nfig.suptitle(\"Total Day of Week Crash Casualties from {0} to {1} by Category\".format(\n    start_date, end_date), fontsize=title_fontsize)\nfig.supxlabel(\"Day of Week\", fontsize=label_fontsize)\nfig.supylabel(\"Counts\", fontsize=label_fontsize)\n\n# crash.set_index('MONTH_NAME').loc[month_abbr_order].groupby(by=['MONTH_NAME']).agg({'PEDESTRIAN_CASUALTY_COUNT': 'sum'}).plot(kind='bar')\ncrash_casualty_data = create_grouped_casualty_data_by_category(\n    victim_categories, 'day_name', day_abbr_order)\ncrash_casualty_data\ncreate_bar_plots_for_casualty_data(\n    sns, axes, day_abbr_order, crash_casualty_data)\n\n\n\n\n\n\n\nWhat hour of the day should make you stay away?\nThe hour between 5 and 6 pm is the worst time for human casualties, with 40,777 injuries and deaths. The rush-hour times around 5 pm have a high casualty count. The morning rush hour also trends higher, but much lower than the evening rush-hour.\nThe early hours of the morning between 12 and 1 am also having a high body count. This is at a time when you would expect the traffic volume to be low.\n\nCyclists - Follow the trend with 4,167 casualties between 5 and 6 pm.\nMotorists - Get off to an earlier start, with 28,142 casualties between 4 and 5 pm.\nPedestrians - Pedestrians get hit at higher rates between 5 and 6 pm, with 8,6623 casualties since the start of 2013.\n\n\n\nCode - Create Seaborn charts for crash casualties based on the Hour of day.\n#  Create the outer figure box\ncol_ct = 1\nfig, axes = plt.subplots(4, col_ct, figsize=(\n    15, 40), layout=\"constrained\", gridspec_kw=gridspec_kw)\n\nfig.suptitle(\"Total Hour of Day Crash Casualties from {0} to {1} by Category\".format(\n    start_date, end_date), fontsize=title_fontsize)\nfig.supxlabel(\"Hour of Day\", fontsize=label_fontsize)\nfig.supylabel(\"Counts\", fontsize=label_fontsize)\n\ncrash_casualty_data = create_grouped_casualty_data_by_category(\n    victim_categories, 'hour', hour_order)\n\n#  Create the inner charts\ncreate_bar_plots_for_casualty_data(\n    sns, axes, hour_order, crash_casualty_data)"
  },
  {
    "objectID": "crash_time_period_stats.html#peak-times-for-traffic-related-casualties-in-new-york-city",
    "href": "crash_time_period_stats.html#peak-times-for-traffic-related-casualties-in-new-york-city",
    "title": "NYC Collision Data Analysis",
    "section": "",
    "text": "What month of the year? …what day of the week? …what time of day?\nHas the most human casualties on New York’s streets?\n\nI’ve spent considerable time walking, biking, driving and taking public transport in this busy city. Just like many New Yorkers, I’ve also had numerous close calls with vehicles while crossing wide streets, where traffic turns onto your crossing lane as you try to make it to the other side in one piece.\nUsing the information provided by NYC Open Data, I wanted to find out when most human casualty causing collisions occur, and how I could best present that information.\n\n\n\n\n\n\nTip\n\n\n\nYou can skip the explanations and go straight to the results.\nor,\nYou can read on and see how I came up with these numbers.\n\n\n\n\n\n\n\n\nTechnology Used\n\n\n\n\nPython\nJupyter Notebook\npandas\nMatplotlib\nSeaborn\nnbdev\n\n\n\n\n\n\n\nCode - Import All Required Python Modules\nimport datetime\nfrom pathlib import Path\n\nimport matplotlib.pyplot as plt\n\n# Import All Required Python Modules\nimport numpy as np\nimport pandas as pd\nimport seaborn as sns\n\n\n\n\nCode - Data Formatting Functions\n# Data Formatting Functions\n\n\ndef empty_to_zero(val):\n    \"\"\"Converts empty values to 0\"\"\"\n    val = val.strip(\"\\s+\")\n    return val if len(val) else 0\n\n\ndef convert_to_numeric(df, column_list):\n    \"\"\"Given a list of DataFrame columns, it converts the empty values to zero\"\"\"\n    df[column_list] = df[column_list].apply(pd.to_numeric, errors=\"coerce\")\n\n\n\n\nCode - Set Up Some Global Variables\n# Set Up Some Global Variables\n\n# I'm omitting longitude, latitude, the vehicle types as well as crash contributing factors.\ncols_requested = [\n    \"COLLISION_ID\",\n    \"CRASH DATE\",\n    \"CRASH TIME\",\n    \"BOROUGH\",\n    \"ZIP CODE\",\n    \"LOCATION\",\n    \"ON STREET NAME\",\n    \"CROSS STREET NAME\",\n    \"OFF STREET NAME\",\n    \"NUMBER OF PERSONS INJURED\",\n    \"NUMBER OF PERSONS KILLED\",\n    \"NUMBER OF PEDESTRIANS INJURED\",\n    \"NUMBER OF PEDESTRIANS KILLED\",\n    \"NUMBER OF CYCLIST INJURED\",\n    \"NUMBER OF CYCLIST KILLED\",\n    \"NUMBER OF MOTORIST INJURED\",\n    \"NUMBER OF MOTORIST KILLED\",\n]\n\n# To ensure that the colums are of the expected data type\ncrash_dtypes = {\n    \"CRASH DATE\": str,\n    \"CRASH TIME\": str,\n    \"BOROUGH\": str,\n    \"ZIP CODE\": str,\n    \"LOCATION\": str,\n    \"ON STREET NAME\": str,\n    \"CROSS STREET NAME\": str,\n    \"OFF STREET NAME\": str,\n}\n\n# Rename some colums to ones that I believe are shorter and/or more meaningful\ncols_rename = {\n    \"CRASH DATE\": \"DATE\",\n    \"CRASH TIME\": \"TIME\",\n    \"ZIP CODE\": \"ZIP_CODE\",\n    \"ON STREET NAME\": \"ON_STREET_NAME\",\n    \"CROSS STREET NAME\": \"CROSS_STREET_NAME\",\n    \"OFF STREET NAME\": \"OFF_STREET_NAME\",\n    \"NUMBER OF PERSONS INJURED\": \"NUM_PERSONS_INJURED\",\n    \"NUMBER OF PERSONS KILLED\": \"NUM_PERSONS_KILLED\",\n    \"NUMBER OF PEDESTRIANS INJURED\": \"NUM_PEDESTRIANS_INJURED\",\n    \"NUMBER OF PEDESTRIANS KILLED\": \"NUM_PEDESTRIANS_KILLED\",\n    \"NUMBER OF CYCLIST INJURED\": \"NUM_CYCLISTS_INJURED\",\n    \"NUMBER OF CYCLIST KILLED\": \"NUM_CYCLISTS_KILLED\",\n    \"NUMBER OF MOTORIST INJURED\": \"NUM_MOTORISTS_INJURED\",\n    \"NUMBER OF MOTORIST KILLED\": \"NUM_MOTORISTS_KILLED\",\n}\n\n# Columns that contain numeric values\nnumeric_cols = [\n    \"NUM_PERSONS_INJURED\",\n    \"NUM_PERSONS_KILLED\",\n    \"NUM_PEDESTRIANS_INJURED\",\n    \"NUM_PEDESTRIANS_KILLED\",\n    \"NUM_CYCLISTS_INJURED\",\n    \"NUM_CYCLISTS_KILLED\",\n    \"NUM_MOTORISTS_INJURED\",\n    \"NUM_MOTORISTS_KILLED\",\n]\n\n# These ordered lists are useful for plotting charts\nday_names_order = [\n    \"Monday\",\n    \"Tuesday\",\n    \"Wednesday\",\n    \"Thursday\",\n    \"Friday\",\n    \"Saturday\",\n    \"Sunday\",\n]\nday_abbr_order = [d[0:3] for d in day_names_order]\nmonth_names_order = [\n    \"January\",\n    \"February\",\n    \"March\",\n    \"April\",\n    \"May\",\n    \"June\",\n    \"July\",\n    \"August\",\n    \"September\",\n    \"October\",\n    \"November\",\n    \"December\",\n]\nmonth_abbr_order = [m[0:3] for m in month_names_order]\n\n# The following DataFrame columns that will have their empty values converted to zero using the\n# 'empty_to_zero' function\nconvert_cols = {\n    \"NUMBER OF PERSONS INJURED\": empty_to_zero,\n    \"NUMBER OF PERSONS KILLED\": empty_to_zero,\n    \"NUMBER OF PEDESTRIANS INJURED\": empty_to_zero,\n    \"NUMBER OF PEDESTRIANS KILLED\": empty_to_zero,\n    \"NUMBER OF CYCLIST INJURED\": empty_to_zero,\n    \"NUMBER OF CYCLIST KILLED\": empty_to_zero,\n    \"NUMBER OF MOTORIST INJURED\": empty_to_zero,\n    \"NUMBER OF MOTORIST KILLED\": empty_to_zero,\n}\n\n# These are the 4 categories supplied by the NYPD\nvictim_categories = [\"person\", \"cyclist\", \"motorist\", \"pedestrian\"]\n# 'person' status should be a combination of the other three categories\n# TODO I need to verify the relationship between 'person' and the other three categories\n\n# These are the Matplotlib Tableau colors\nbar_colors = [\n    \"tab:blue\",\n    \"tab:orange\",\n    \"tab:green\",\n    \"tab:red\",\n    \"tab:purple\",\n    \"tab:brown\",\n    \"tab:pink\",\n    \"tab:gray\",\n    \"tab:olive\",\n    \"tab:cyan\",\n]\n\nbase_colors = [\"b\", \"g\", \"r\", \"c\", \"m\", \"y\", \"k\", \"w\"]\n\n# Chart Colors\ncolor = \"k\"\nplt.rcParams[\"text.color\"] = color\nplt.rcParams[\"axes.labelcolor\"] = color\nplt.rcParams[\"xtick.color\"] = \"b\"\nplt.rcParams[\"ytick.color\"] = \"b\"\n\n\n\n\n\n\n\n\n\nCode - Creating the ‘crash’ DataFrame from the NYPD CSV file.\ncollision_filename = \"Motor_Vehicle_Collisions_Aug15_2023.csv\"\n\n# Using the Pandas 'read_csv' function\ncrash = pd.read_csv(\n    Path.cwd().joinpath(\"..\").joinpath(collision_filename),\n    index_col=\"COLLISION_ID\",\n    usecols=cols_requested,\n    dtype=crash_dtypes,\n    converters=convert_cols,\n)\n\n\n\n\nRename some of the DataFrame columns\noriginal_col_names = crash.columns.to_list()\n\n# Rename the columns using the list of new names, 'cols_rename'\ncrash.rename(columns=cols_rename, inplace=True)\n\nprint(\"Original Crash Column Names\\n{}\".format(original_col_names))\nprint(\"\\nRenamed Crash Columns Names\\n{}\".format(crash.columns.to_list()))\n\n\nOriginal Crash Column Names\n['CRASH DATE', 'CRASH TIME', 'BOROUGH', 'ZIP CODE', 'LOCATION', 'ON STREET NAME', 'CROSS STREET NAME', 'OFF STREET NAME', 'NUMBER OF PERSONS INJURED', 'NUMBER OF PERSONS KILLED', 'NUMBER OF PEDESTRIANS INJURED', 'NUMBER OF PEDESTRIANS KILLED', 'NUMBER OF CYCLIST INJURED', 'NUMBER OF CYCLIST KILLED', 'NUMBER OF MOTORIST INJURED', 'NUMBER OF MOTORIST KILLED']\n\nRenamed Crash Columns Names\n['DATE', 'TIME', 'BOROUGH', 'ZIP_CODE', 'LOCATION', 'ON_STREET_NAME', 'CROSS_STREET_NAME', 'OFF_STREET_NAME', 'NUM_PERSONS_INJURED', 'NUM_PERSONS_KILLED', 'NUM_PEDESTRIANS_INJURED', 'NUM_PEDESTRIANS_KILLED', 'NUM_CYCLISTS_INJURED', 'NUM_CYCLISTS_KILLED', 'NUM_MOTORISTS_INJURED', 'NUM_MOTORISTS_KILLED']\n\n\n\n\nCode - Convert string values to numeric for specific ‘numeric’ columns.\n# Ensure that the 'numeric_cols' column values are numeric and not string values\nconvert_to_numeric(crash, numeric_cols)\n\n\n\n\nCode - General Description of the ‘crash’ dataset\n#  General Description of the dataset.\n\n# The 'set_option' is used here to display numeric values as a 'float' rather\n# than the default scientific notation\npd.set_option(\"display.float_format\", lambda x: \"%8.2f\" % x)\ncrash.describe()\n\n\n\n\n\n\n\n\n\nNUM_PERSONS_INJURED\nNUM_PERSONS_KILLED\nNUM_PEDESTRIANS_INJURED\nNUM_PEDESTRIANS_KILLED\nNUM_CYCLISTS_INJURED\nNUM_CYCLISTS_KILLED\nNUM_MOTORISTS_INJURED\nNUM_MOTORISTS_KILLED\n\n\n\n\ncount\n2017370.00\n2017370.00\n2017370.00\n2017370.00\n2017370.00\n2017370.00\n2017370.00\n2017370.00\n\n\nmean\n0.30\n0.00\n0.06\n0.00\n0.03\n0.00\n0.22\n0.00\n\n\nstd\n0.69\n0.04\n0.24\n0.03\n0.16\n0.01\n0.65\n0.03\n\n\nmin\n0.00\n0.00\n0.00\n0.00\n0.00\n0.00\n0.00\n0.00\n\n\n25%\n0.00\n0.00\n0.00\n0.00\n0.00\n0.00\n0.00\n0.00\n\n\n50%\n0.00\n0.00\n0.00\n0.00\n0.00\n0.00\n0.00\n0.00\n\n\n75%\n0.00\n0.00\n0.00\n0.00\n0.00\n0.00\n0.00\n0.00\n\n\nmax\n43.00\n8.00\n27.00\n6.00\n4.00\n2.00\n43.00\n5.00\n\n\n\n\n\n\n\n\n\nThe count tells us that there are over 2M rows of data. The maximum(max) NUM_PERSONS_INJURED in one collision is 43.\nThe average(mean) NUM_PERSONS_INJURED per collision is 0.3, or almost 1 for every three collisions. You can find more details on the pandas.DataFrame.describe function here.\n\n\n\n\nThe original ‘DATE’ is a “date only” field without the time. After merging the date and time columns, convert ‘DATE’ to a Python “datetime” object. Then remove the now unnecessary ‘TIME’ column.\n\n\n\nCode - Combine the DATE and TIME columns into the DATE column\n# Merge\ncrash[\"DATE\"] = pd.to_datetime(crash[\"DATE\"] + \" \" + crash[\"TIME\"])\n# Remove the 'TIME' column\ncrash.drop(columns=[\"TIME\"], inplace=True)\n# Convert to Python 'datetime'\ncrash[\"DATE\"] = pd.to_datetime(crash[\"DATE\"])\n\n\n\ncrash[\"DATE\"].describe()\n\ncount                          2017370\nmean     2017-05-13 17:54:54.650598912\nmin                2012-07-01 00:05:00\n25%                2014-12-19 13:00:15\n50%                2017-03-29 10:07:30\n75%                2019-06-09 17:50:00\nmax                2023-08-12 23:56:00\nName: DATE, dtype: object\n\n\n\n\n\nWe can see that the first collision record (min) was on July 8, 2012 The last record (max), for this iteration is August 12, 2023.\n\n\nCode - Create a ‘start_date’ and an ‘end_date’ variable.\n# Create a 'start_date' and 'end_date' variable, which is useful for our charts\nstart_date = crash[\"DATE\"].dt.date.min()\nend_date = crash[\"DATE\"].dt.date.max()\n\nprint(\"Start Date: {0} - End Date: {1}\".format(start_date, end_date))\n\n\nStart Date: 2012-07-01 - End Date: 2023-08-12\n\n\n\n\n\n\n\n\nThe Unknown Borough\n\n\n\nThe BOROUGH column should contain one of the 5 boroughs of New York City, BROOKLYN, BRONX, MANHATTAN, QUEENS and STATEN ISLAND.\nUnfortunately, many of the ‘BOROUGH’ fields are empty, as the NYPD don’t record it in certain situations.\nFor example, if the collision occurred on one of the main bridges between boroughs, or if the collision occurred on any one of NYC’s many expressways or parkways.\nFurther investigation would be needed to confirm this.\nI previously reached out to the open data team for more information on this, but got no reply.\n\n\n\n\nCode - Replace empty ‘BOROUGH’ values with ‘UNKNOWN’\ncrash.fillna(value={\"BOROUGH\": \"UNKNOWN\"}, inplace=True)\n\n\n\n\nCode - Describe the ‘BOROUGH’ column\ncrash[\"BOROUGH\"].describe()\n\n\ncount     2017370\nunique          6\ntop       UNKNOWN\nfreq       627585\nName: BOROUGH, dtype: object\n\n\n\n\n\n\nunique\n\nUnique borough name count, which includes the ‘UNKNOWN’ borough\n\ntop\n\n‘UNKNOWN’ is the most frequent borough recorded\n\nfreq\n\nTells us the occurrence of ‘UNKNOWN’ borough records\n\ncount\n\nHow many rows of data in the dataset\n\n\n\n\n\n\n\nCode - Replace empty ZIP_CODE’s with ‘UNKNOWN’\n# Replace empty ZIP_CODE's with 'UNKNOWN'\ncrash.fillna(value={\"ZIP_CODE\": \"UNKNOWN\"}, inplace=True)\n\n\n\n\n\n\n\n\nThe Unknown Zip Code\n\n\n\nAs with the BOROUGH column, the postal ZIP_CODE is often left empty.\nEmpty Zips will be replaced by ‘UNKNOWN’.\n\n\n\n\nCode - Describe the ‘ZIP_CODE’ column\ncrash[\"ZIP_CODE\"].describe()\n\n\ncount     2017370\nunique        235\ntop       UNKNOWN\nfreq       627823\nName: ZIP_CODE, dtype: object\n\n\n\n\n\nUsing crash['ZIP_CODE'].describe(), we see that the ZIP_CODE with the most collisions, top, is 11207, in Brooklyn.\nThe freq gives a count of collisions for this zip code. 11207 has a large population, almost 80,000 people, which may account for these numbers. A future project would be to see how these zip code counts relate to their population. The unique number tells us that there are 234 NYC zip codes with recorded collisions in this dataset.\n\n\n\n\n\nCode - Create new columns, YEAR, MONTH_NAME, DAY_NAME and HOUR\n#  by extracting information from the *DATE* column\n\n# Set up some date columns: YEAR, MONTH_NAME, DAY_NAME, HOUR\n# Remove all records for 2012 as it's only a partial year.\n\ncrash[\"YEAR\"] = crash[\"DATE\"].dt.year\n\n# Get rid of 2012 as it only has 6 months of data\nno_2012_mask = crash[\"YEAR\"] &gt; 2012\ncrash = crash[no_2012_mask]\n\n# Reset the start_date variable to reflect the change\nstart_date = crash[\"DATE\"].dt.date.min()\nyear_order = crash[\"YEAR\"].sort_values().unique()\n\n# Create a MONTH_NAME column. Actually, month abbreviated name\ncrash[\"MONTH_NAME\"] = crash[\"DATE\"].dt.month_name().str[0:3]\n\n# Create a HOUR column, which reflects the hour of day that the collision occurred\ncrash[\"HOUR\"] = crash[\"DATE\"].dt.strftime(\"%H\")\n\n# Need to convert hour_order to a Python list instead of Numpy array\nhour_order = crash[\"HOUR\"].sort_values().unique().tolist()\n\ncrash[\"DAY_NAME\"] = crash[\"DATE\"].dt.strftime(\"%a\")\n\nprint(\"Year, Month and Hour order lists will be used for charting.\")\nprint(\"Year order: {}\\n\".format(year_order))\nprint(\"Month abbreviations: {}\\n\".format(crash.MONTH_NAME.unique()))\nprint(\"Hour order: {}\\n\".format(hour_order))\n\n\nYear, Month and Hour order lists will be used for charting.\nYear order: [2013 2014 2015 2016 2017 2018 2019 2020 2021 2022 2023]\n\nMonth abbreviations: ['Sep' 'Mar' 'Jun' 'Dec' 'Apr' 'Jul' 'Feb' 'Aug' 'Nov' 'May' 'Jan' 'Oct']\n\nHour order: ['00', '01', '02', '03', '04', '05', '06', '07', '08', '09', '10', '11', '12', '13', '14', '15', '16', '17', '18', '19', '20', '21', '22', '23']\n\n\n\n\n\n\n\n\nThis chart will give an overview of the total deaths and injuries on NYC roads.\n\n\n\nCode - Create the yearly Killed/Injured collections.\ncrash_by_year_killed = (\n    crash.groupby(\"YEAR\")[\"NUM_PERSONS_KILLED\"].sum().sort_values(ascending=False)\n)\ncrash_by_year_injured = (\n    crash.groupby(\"YEAR\")[\"NUM_PERSONS_INJURED\"].sum().sort_values(ascending=False)\n)\n\n\n\n\nCode - Create Matplotlib bar chart with yearly details on the number of people killed and injured.\nkilled_injured = {\n    \"Killed\": crash_by_year_killed.loc[year_order],\n    \"Injured\": crash_by_year_injured.loc[year_order],\n}\n\nx_loc = np.arange(len(year_order))  # the label locations\nwidth = 0.45  # the width of the bars\nmultiplier = 0\nfig, ax = plt.subplots(figsize=(10, 15), layout=\"constrained\")\n\n# Create the Injured/Killed bars for each year\nfor killed_or_injured, count in killed_injured.items():\n    offset = width * multiplier\n    rects = ax.bar(x_loc + offset, count, width, label=killed_or_injured)\n    ax.bar_label(rects, padding=3)\n    multiplier += 1\n\n# Add some text for labels, title and custom x-axis tick labels, etc.\nax.set_xlabel(\"Year\", fontsize=14)\nax.set_ylabel(\"Killed/Injured Count\", fontsize=14)\nax.set_title(\n    \"Persons Killed and Injured From {0} to {1}\".format(start_date, end_date),\n    fontsize=20,\n)\nax.set_xticks(x_loc + (width / 2), year_order)\nax.legend(loc=\"upper left\")\nax.set_yscale(\"log\")\nplt.show()\n\n\n\n\n\n\n\nThe chart shows that traffic fatalities had a general downward trend from the high of 297 in 2013 to a low of 231 in 2018. The trend is upwards from 2019 to 2021, which was just 1 off the worst year, 2013. For injuries, 2016 to 2019 were the worst. The following years are a slight improvement, but no visible downward trend yet.\n\n\n\n\nFor each category, Person, Pedestrian, Cyclist and Motorist there will be a new ‘CASUALTY’ column with the combined Injured/Killed values\nThe new columns are, PERSON_CASUALTY_COUNT, PEDESTRIAN_CASUALTY_COUNT, CYCLIST_CASUALTY_COUNT and MOTORIST_CASUALTY_COUNT\n\n\n\nCode - Combine the INJURED and KILLED columns into one ‘CASUALTIES’ column.\ncrash[\"PERSON_CASUALTY_COUNT\"] = crash.NUM_PERSONS_INJURED + crash.NUM_PERSONS_KILLED\ncrash[\"PEDESTRIAN_CASUALTY_COUNT\"] = (\n    crash.NUM_PEDESTRIANS_INJURED + crash.NUM_PEDESTRIANS_KILLED\n)\n\ncrash[\"CYCLIST_CASUALTY_COUNT\"] = crash.NUM_CYCLISTS_INJURED + crash.NUM_CYCLISTS_KILLED\ncrash[\"MOTORIST_CASUALTY_COUNT\"] = (\n    crash.NUM_MOTORISTS_INJURED + crash.NUM_MOTORISTS_KILLED\n)\n\nkilled_injured_mask = (crash.NUM_PERSONS_KILLED &gt; 0) & (crash.NUM_PERSONS_INJURED &gt; 0)\n\n\n\n\n\n\nA function to print value counts above or to the side of Barchart bars.\nI got the original function from this very useful site, statology.org.\nThe original function is here.\n\n\n\nCode - Function to print value counts above or to the side of barchart bars\ndef show_values(axs, orient=\"v\", space=0.01):\n    def _single(ax):\n        if orient == \"v\":\n            for p in ax.patches:\n                _x = p.get_x() + p.get_width() / 2\n                _y = p.get_y() + p.get_height() + (p.get_height() * 0.01)\n                value = \"{:6,.0f}\".format(p.get_height())\n                ax.text(_x, _y, value, ha=\"center\", fontsize=12)\n        elif orient == \"h\":\n            for p in ax.patches:\n                _x = p.get_x() + p.get_width() + float(space)\n                _y = p.get_y() + p.get_height() - (p.get_height() * 0.5)\n                value = \"{:6,.0f}\".format(p.get_width())\n                ax.text(_x, _y, value, ha=\"left\", fontsize=12)\n\n    if isinstance(axs, np.ndarray):\n        for idx, ax in np.ndenumerate(axs):\n            _single(ax)\n    else:\n        _single(axs)\n\n\n\n\nCode - Helper functions for creating multiple charts based on Grouped statistics.\n# Statistics will be created for the below columns.\n#   PERSON_CASUALTY_COUNT\n#   PEDESTRIAN_CASUALTY_COUNT\n#   CYCLIST_CASUALTY_COUNT\n#   MOTORIST_CASUALTY_COUNT\n\n\ndef create_grouped_casualty_data_by_category(\n    victim_categories, time_group=\"YEAR\", order_list=None\n):\n    \"\"\"\n    Create multiple Seaborn SubPlot charts based on:\n    PERSON_CASUALTY_COUNT, PEDESTRIAN_CASUALTY_COUNT, CYCLIST_CASUALTY_COUNT and MOTORIST_CASUALTY_COUNT\n    time_group can be 'HOUR', 'DAY_OF_WEEK', 'MONTH_NAME', 'YEAR'\n    \"\"\"\n    time_group = time_group.upper()\n    all_casualty_data = []\n\n    for category in victim_categories:\n        cat_upper = category.upper()\n        casualty_label = cat_upper + \"_CASUALTY_COUNT\"\n\n        casualty_data = crash.groupby(by=[time_group], as_index=True).agg(\n            {casualty_label: \"sum\"}\n        )\n        if order_list and len(order_list):\n            casualty_data = casualty_data.loc[order_list]\n\n        category_data = {\n            \"category\": category,\n            \"casualty_label\": casualty_label,\n            \"casualty_data\": casualty_data,\n        }\n\n        all_casualty_data.append(category_data)\n    return all_casualty_data\n\n\ndef create_bar_plots_for_casualty_data(sns, axes, order_list, crash_victims_data):\n    for idx, category_data in enumerate(crash_victims_data):\n        xlabel = None\n        ylabel = None\n        # Casualty Chart\n        category_title = category_data[\"category\"].title()\n        chart_title = \"{0} Casualties\".format(category_title)\n\n        casualty_max = category_data[\"casualty_data\"][\n            category_data[\"casualty_label\"]\n        ].max()\n        casualty_values = category_data[\"casualty_data\"][\n            category_data[\"casualty_label\"]\n        ].to_list()\n\n        casualty_colors = [\n            \"k\" if (x &gt;= casualty_max) else \"tab:red\" for x in casualty_values\n        ]\n\n        ax = axes[idx]\n\n        sns.barplot(\n            data=category_data[\"casualty_data\"],\n            x=order_list,\n            order=order_list,\n            y=category_data[\"casualty_label\"],\n            palette=casualty_colors,\n            ax=ax,\n        ).set(title=chart_title, xlabel=xlabel, ylabel=ylabel)\n\n        show_values(axes)\n\n\n\n\nCode - Set some global Matplotlib/Seaborn chart variables.\ntitle_fontsize = 20\nlabel_fontsize = 18\n# For spacing between charts on the same grid\ngridspec_kw = {\"wspace\": 0.1, \"hspace\": 0.1}\n\nsns.set_style(\"whitegrid\")\n\n\n\n\n\n\n\n2018 was the worst for human casualties, with 62,172 injuries and deaths. 2019 was a close second, followed by 2017 and 2016.\n\nCyclists - 2020 was by far the worst year with 5,605 casualties.\nMotorists - 2018 was their worst year with 46,168 casualties.\nPedestrians - 2013 was their worst year with 12,164 casualties. Things have improved a little for them since then.\n\n\n\nCode - Create Seaborn charts for crash casualties based on year.\ncol_ct = 1\n#  Create the outer figure box\nfig, axes = plt.subplots(\n    4, col_ct, figsize=(15, 40), layout=\"constrained\", gridspec_kw=gridspec_kw\n)\nfig.suptitle(\n    \"Total Yearly Crash Casualties from {0} to {1} by Category\".format(\n        start_date, end_date\n    ),\n    fontsize=title_fontsize,\n)\nfig.supxlabel(\"Year\", fontsize=label_fontsize)\nfig.supylabel(\"Counts\", fontsize=label_fontsize)\n\ncrash_casualty_data = create_grouped_casualty_data_by_category(\n    victim_categories, \"year\"\n)\ncreate_bar_plots_for_casualty_data(sns, axes, year_order, crash_casualty_data)\n\n\n\n\n\n\n\n\nJune has been the worst month for human casualties, with 56,240 injuries and deaths.\nThe Summer months in general seem to be bad for motorists and cyclists, while winter is bad for pedestrians.\n\nCyclists - July has been the worst, with 6,270 casualties. August and June follow after that.\nMotorists - July has been the worst, with 41,140 casualties. June is a close second.\nPedestrians - December has been the worst, with 10,750 casualties. January is a close second.\n\nWinter time may be a good time to stay on public transport or indoors.\n\n\n\n\nCode - Create Seaborn charts for crash casualties based on month.\n# Create the outer figure box\ncol_ct = 1\nfig, axes = plt.subplots(\n    4, col_ct, figsize=(20, 30), layout=\"constrained\", gridspec_kw=gridspec_kw\n)\n\nfig.suptitle(\n    \"Total Monthly Crash Casualties from {0} to {1} by Category\".format(\n        start_date, end_date\n    ),\n    fontsize=title_fontsize,\n)\nfig.supxlabel(\"Month\", fontsize=label_fontsize)\nfig.supylabel(\"Counts\", fontsize=label_fontsize)\n\ncrash_casualty_data = create_grouped_casualty_data_by_category(\n    victim_categories, \"month_name\", month_abbr_order\n)\ncreate_bar_plots_for_casualty_data(sns, axes, month_abbr_order, crash_casualty_data)\n\n\n\n\n\n\n\n\nFriday tends to be the worst day for human casualties, with 90,089 injuries and deaths. Sunday seems to be the safest.\n\nCyclists - Friday is a bad day to bike in NYC, with 8,008 casualties since the start of 2013.\nMotorists - Friday and Saturday are equally bad, with 63,774 casualties each.\nPedestrians - Pedestrians should also avoid Fridays, with 17,337 casualties since the start of 2013.\n\n\n\nCode - Create Seaborn charts for crash casualties based on day of the week.\ncol_ct = 1\nfig, axes = plt.subplots(\n    4, col_ct, figsize=(15, 40), layout=\"constrained\", gridspec_kw=gridspec_kw\n)\n\nfig.suptitle(\n    \"Total Day of Week Crash Casualties from {0} to {1} by Category\".format(\n        start_date, end_date\n    ),\n    fontsize=title_fontsize,\n)\nfig.supxlabel(\"Day of Week\", fontsize=label_fontsize)\nfig.supylabel(\"Counts\", fontsize=label_fontsize)\n\n# crash.set_index('MONTH_NAME').loc[month_abbr_order].groupby(by=['MONTH_NAME']).agg({'PEDESTRIAN_CASUALTY_COUNT': 'sum'}).plot(kind='bar')\ncrash_casualty_data = create_grouped_casualty_data_by_category(\n    victim_categories, \"day_name\", day_abbr_order\n)\ncrash_casualty_data\ncreate_bar_plots_for_casualty_data(sns, axes, day_abbr_order, crash_casualty_data)\n\n\n\n\n\n\n\n\nThe hour between 5 and 6 pm is the worst time for human casualties, with 40,777 injuries and deaths. The rush-hour times around 5 pm have a high casualty count. The morning rush hour also trends higher, but much lower than the evening rush-hour.\nThe early hours of the morning between 12 and 1 am also having a high body count. This is at a time when you would expect the traffic volume to be low.\n\nCyclists - Follow the trend with 4,167 casualties between 5 and 6 pm.\nMotorists - Get off to an earlier start, with 28,142 casualties between 4 and 5 pm.\nPedestrians - Pedestrians get hit at higher rates between 5 and 6 pm, with 8,6623 casualties since the start of 2013.\n\n\n\nCode - Create Seaborn charts for crash casualties based on the Hour of day.\n#  Create the outer figure box\ncol_ct = 1\nfig, axes = plt.subplots(\n    4, col_ct, figsize=(15, 40), layout=\"constrained\", gridspec_kw=gridspec_kw\n)\n\nfig.suptitle(\n    \"Total Hour of Day Crash Casualties from {0} to {1} by Category\".format(\n        start_date, end_date\n    ),\n    fontsize=title_fontsize,\n)\nfig.supxlabel(\"Hour of Day\", fontsize=label_fontsize)\nfig.supylabel(\"Counts\", fontsize=label_fontsize)\n\ncrash_casualty_data = create_grouped_casualty_data_by_category(\n    victim_categories, \"hour\", hour_order\n)\n\n#  Create the inner charts\ncreate_bar_plots_for_casualty_data(sns, axes, hour_order, crash_casualty_data)\n\n\n\n\n\n\n\n\nNo major surprises with most of the data. Most injuries and deaths occur during the evening rush hour, when traffic volume is at its highest and people are in a rush to get home. This is particularly evident on Fridays, when the urge to get home seems to be the greatest.\nI’m still curious as to why more motorist casualties on Saturday are equal to the Friday’s total. It could be because of Friday night “madness” or some other reason. I’d like to spend more time digging into that.\nIt’s also not too surprising that the cyclists are getting mowed down more often in the Summer months, as there are probably a lot more bikes on the road during those times.\nFor pedestrians, the upward trend in casualties from October to January is a little surprising. The December peak may be because of holiday shopping and holiday parties? That’s something I’ll spend more time analyzing in the future.\n\n\n\nThis Project on GitHub\nMe on Linkedin\n\n\nNYC Streetsblog\nHellgateNYC\nNYC Open Data\nnbdev really helped setup this blog post"
  },
  {
    "objectID": "crash_time_period_stats.html#what-day-of-the-week",
    "href": "crash_time_period_stats.html#what-day-of-the-week",
    "title": "NYC Collision Data Analysis",
    "section": "",
    "text": "…what time of day? …what month of the year? Has the most human casualties on New York’s streets?\n\n\n\nI’ve spent considerable time walking, biking, driving and taking public transport in this busy city. Just like many New Yorkers, I’ve also had numerous close calls with vehicles while crossing wide streets where traffic turns onto your crossing lane while you try to make it to the other side in one piece.\nUsing the information provided by NYC Open Data, I wanted to find out when most human casualty causing collisions occur, and how I could best present that information.\nHere I’m using Python with Jupyter Notebook, pandas, Matplotlib and Seaborn to present some of that information.\nYou can skip the explanations and go straight to the results. Or,\nYou can read on and see how I came up with these numbers using Python and the pandas library.\n\n\nCode - Import All Required Python Modules\nimport datetime\nfrom pathlib import Path\n\nimport matplotlib.pyplot as plt\n\n# Import All Required Python Modules\nimport numpy as np\nimport pandas as pd\nimport seaborn as sns\n\n\n\n\nCode - Data Formatting Functions\n# Data Formatting Functions\n\n\ndef empty_to_zero(val):\n    \"\"\"Converts empty values to 0\"\"\"\n    val = val.strip(\"\\s+\")\n    return val if len(val) else 0\n\n\ndef convert_to_numeric(df, column_list):\n    \"\"\"Given a list of DataFrame columns, it converts the empty values to zero\"\"\"\n    df[column_list] = df[column_list].apply(pd.to_numeric, errors=\"coerce\")\n\n\n\n\nCode - Set Up Some Global Variables\n# Set Up Some Global Variables\n\n# I'm omitting longitude, latitude, the vehicle types as well as crash contributing factors.\ncols_requested = [\n    \"COLLISION_ID\",\n    \"CRASH DATE\",\n    \"CRASH TIME\",\n    \"BOROUGH\",\n    \"ZIP CODE\",\n    \"LOCATION\",\n    \"ON STREET NAME\",\n    \"CROSS STREET NAME\",\n    \"OFF STREET NAME\",\n    \"NUMBER OF PERSONS INJURED\",\n    \"NUMBER OF PERSONS KILLED\",\n    \"NUMBER OF PEDESTRIANS INJURED\",\n    \"NUMBER OF PEDESTRIANS KILLED\",\n    \"NUMBER OF CYCLIST INJURED\",\n    \"NUMBER OF CYCLIST KILLED\",\n    \"NUMBER OF MOTORIST INJURED\",\n    \"NUMBER OF MOTORIST KILLED\",\n]\n\n# To ensure that the colums are of the expected data type\ncrash_dtypes = {\n    \"CRASH DATE\": str,\n    \"CRASH TIME\": str,\n    \"BOROUGH\": str,\n    \"ZIP CODE\": str,\n    \"LOCATION\": str,\n    \"ON STREET NAME\": str,\n    \"CROSS STREET NAME\": str,\n    \"OFF STREET NAME\": str,\n}\n\n# Rename some colums to ones that I believe are shorter and/or more meaningful\ncols_rename = {\n    \"CRASH DATE\": \"DATE\",\n    \"CRASH TIME\": \"TIME\",\n    \"ZIP CODE\": \"ZIP_CODE\",\n    \"ON STREET NAME\": \"ON_STREET_NAME\",\n    \"CROSS STREET NAME\": \"CROSS_STREET_NAME\",\n    \"OFF STREET NAME\": \"OFF_STREET_NAME\",\n    \"NUMBER OF PERSONS INJURED\": \"NUM_PERSONS_INJURED\",\n    \"NUMBER OF PERSONS KILLED\": \"NUM_PERSONS_KILLED\",\n    \"NUMBER OF PEDESTRIANS INJURED\": \"NUM_PEDESTRIANS_INJURED\",\n    \"NUMBER OF PEDESTRIANS KILLED\": \"NUM_PEDESTRIANS_KILLED\",\n    \"NUMBER OF CYCLIST INJURED\": \"NUM_CYCLISTS_INJURED\",\n    \"NUMBER OF CYCLIST KILLED\": \"NUM_CYCLISTS_KILLED\",\n    \"NUMBER OF MOTORIST INJURED\": \"NUM_MOTORISTS_INJURED\",\n    \"NUMBER OF MOTORIST KILLED\": \"NUM_MOTORISTS_KILLED\",\n}\n\n# Columns that contain numeric values\nnumeric_cols = [\n    \"NUM_PERSONS_INJURED\",\n    \"NUM_PERSONS_KILLED\",\n    \"NUM_PEDESTRIANS_INJURED\",\n    \"NUM_PEDESTRIANS_KILLED\",\n    \"NUM_CYCLISTS_INJURED\",\n    \"NUM_CYCLISTS_KILLED\",\n    \"NUM_MOTORISTS_INJURED\",\n    \"NUM_MOTORISTS_KILLED\",\n]\n\n# These ordered lists are useful for plotting charts\nday_names_order = [\n    \"Monday\",\n    \"Tuesday\",\n    \"Wednesday\",\n    \"Thursday\",\n    \"Friday\",\n    \"Saturday\",\n    \"Sunday\",\n]\nday_abbr_order = [d[0:3] for d in day_names_order]\nmonth_names_order = [\n    \"January\",\n    \"February\",\n    \"March\",\n    \"April\",\n    \"May\",\n    \"June\",\n    \"July\",\n    \"August\",\n    \"September\",\n    \"October\",\n    \"November\",\n    \"December\",\n]\nmonth_abbr_order = [m[0:3] for m in month_names_order]\n\n# The following DataFrame columns that will have their empty values converted to zero using the\n# 'empty_to_zero' function\nconvert_cols = {\n    \"NUMBER OF PERSONS INJURED\": empty_to_zero,\n    \"NUMBER OF PERSONS KILLED\": empty_to_zero,\n    \"NUMBER OF PEDESTRIANS INJURED\": empty_to_zero,\n    \"NUMBER OF PEDESTRIANS KILLED\": empty_to_zero,\n    \"NUMBER OF CYCLIST INJURED\": empty_to_zero,\n    \"NUMBER OF CYCLIST KILLED\": empty_to_zero,\n    \"NUMBER OF MOTORIST INJURED\": empty_to_zero,\n    \"NUMBER OF MOTORIST KILLED\": empty_to_zero,\n}\n\n# These are the 4 categories supplied by the NYPD\nvictim_categories = [\"person\", \"cyclist\", \"motorist\", \"pedestrian\"]\n# 'person' status should be a combination of the other three categories\n# TODO I need to verify the relationship between 'person' and the other three categories\n\n# These are the Matplotlib Tableau colors\nbar_colors = [\n    \"tab:blue\",\n    \"tab:orange\",\n    \"tab:green\",\n    \"tab:red\",\n    \"tab:purple\",\n    \"tab:brown\",\n    \"tab:pink\",\n    \"tab:gray\",\n    \"tab:olive\",\n    \"tab:cyan\",\n]\n\nbase_colors = [\"b\", \"g\", \"r\", \"c\", \"m\", \"y\", \"k\", \"w\"]\n\n# Chart Colors\ncolor = \"k\"\nplt.rcParams[\"text.color\"] = color\nplt.rcParams[\"axes.labelcolor\"] = color\nplt.rcParams[\"xtick.color\"] = \"b\"\nplt.rcParams[\"ytick.color\"] = \"b\"\n\n\n\n\n\nThe Collision Dataset provided by NYPD is available here.\n\n\n\nCode - Creating the ‘crash’ DataFrame from the NYPD CSV file.\ncollision_filename = \"Motor_Vehicle_Collisions_Aug15_2023.csv\"\n\n# Using the Pandas 'read_csv' function\ncrash = pd.read_csv(\n    Path.cwd().joinpath(\"..\").joinpath(collision_filename),\n    index_col=\"COLLISION_ID\",\n    usecols=cols_requested,\n    dtype=crash_dtypes,\n    converters=convert_cols,\n)\n\n\n\n\nRename some of the DataFrame columns\noriginal_col_names = crash.columns.to_list()\n\n# Rename the columns using the list of new names, 'cols_rename'\ncrash.rename(columns=cols_rename, inplace=True)\n\nprint(\"Original Crash Column Names\\n{}\".format(original_col_names))\nprint(\"\\nRenamed Crash Columns Names\\n{}\".format(crash.columns.to_list()))\n\n\nOriginal Crash Column Names\n['CRASH DATE', 'CRASH TIME', 'BOROUGH', 'ZIP CODE', 'LOCATION', 'ON STREET NAME', 'CROSS STREET NAME', 'OFF STREET NAME', 'NUMBER OF PERSONS INJURED', 'NUMBER OF PERSONS KILLED', 'NUMBER OF PEDESTRIANS INJURED', 'NUMBER OF PEDESTRIANS KILLED', 'NUMBER OF CYCLIST INJURED', 'NUMBER OF CYCLIST KILLED', 'NUMBER OF MOTORIST INJURED', 'NUMBER OF MOTORIST KILLED']\n\nRenamed Crash Columns Names\n['DATE', 'TIME', 'BOROUGH', 'ZIP_CODE', 'LOCATION', 'ON_STREET_NAME', 'CROSS_STREET_NAME', 'OFF_STREET_NAME', 'NUM_PERSONS_INJURED', 'NUM_PERSONS_KILLED', 'NUM_PEDESTRIANS_INJURED', 'NUM_PEDESTRIANS_KILLED', 'NUM_CYCLISTS_INJURED', 'NUM_CYCLISTS_KILLED', 'NUM_MOTORISTS_INJURED', 'NUM_MOTORISTS_KILLED']\n\n\n\n\nCode - Convert string values to numeric for specific ‘numeric’ columns.\n# Ensure that the 'numeric_cols' column values are numeric and not string values\nconvert_to_numeric(crash, numeric_cols)\n\n\n\n\nCode - General Description of the ‘crash’ dataset\n#  General Description of the dataset.\n\n# The 'set_option' is used here to display numeric values as a 'float' rather\n# than the default scientific notation\npd.set_option(\"display.float_format\", lambda x: \"%8.2f\" % x)\ncrash.describe()\n\n\n\n\n\n\n\n\n\nNUM_PERSONS_INJURED\nNUM_PERSONS_KILLED\nNUM_PEDESTRIANS_INJURED\nNUM_PEDESTRIANS_KILLED\nNUM_CYCLISTS_INJURED\nNUM_CYCLISTS_KILLED\nNUM_MOTORISTS_INJURED\nNUM_MOTORISTS_KILLED\n\n\n\n\ncount\n2017370.00\n2017370.00\n2017370.00\n2017370.00\n2017370.00\n2017370.00\n2017370.00\n2017370.00\n\n\nmean\n0.30\n0.00\n0.06\n0.00\n0.03\n0.00\n0.22\n0.00\n\n\nstd\n0.69\n0.04\n0.24\n0.03\n0.16\n0.01\n0.65\n0.03\n\n\nmin\n0.00\n0.00\n0.00\n0.00\n0.00\n0.00\n0.00\n0.00\n\n\n25%\n0.00\n0.00\n0.00\n0.00\n0.00\n0.00\n0.00\n0.00\n\n\n50%\n0.00\n0.00\n0.00\n0.00\n0.00\n0.00\n0.00\n0.00\n\n\n75%\n0.00\n0.00\n0.00\n0.00\n0.00\n0.00\n0.00\n0.00\n\n\nmax\n43.00\n8.00\n27.00\n6.00\n4.00\n2.00\n43.00\n5.00\n\n\n\n\n\n\n\n\n\n\nThe count tells us that there are over 2M rows of data. The maximum(max) NUM_PERSONS_INJURED in one collision is 43.\nThe average(mean) NUM_PERSONS_INJURED per collision is 0.3, or almost 1 for every three collisions. You can find more details on the pandas.DataFrame.describe function here.\n\n\n\n\nThe original ‘DATE’ is a “date only” field without the time. After merging the date and time columns, convert ‘DATE’ to a Python “datetime” object. Then remove the now unnecessary ‘TIME’ column.\n\n\n\nCode - Combine the DATE and TIME columns into the DATE column\n# Merge\ncrash[\"DATE\"] = pd.to_datetime(crash[\"DATE\"] + \" \" + crash[\"TIME\"])\n# Remove the 'TIME' column\ncrash.drop(columns=[\"TIME\"], inplace=True)\n# Convert to Python 'datetime'\ncrash[\"DATE\"] = pd.to_datetime(crash[\"DATE\"])\n\n\n\ncrash[\"DATE\"].describe()\n\ncount                          2017370\nmean     2017-05-13 17:54:54.650598912\nmin                2012-07-01 00:05:00\n25%                2014-12-19 13:00:15\n50%                2017-03-29 10:07:30\n75%                2019-06-09 17:50:00\nmax                2023-08-12 23:56:00\nName: DATE, dtype: object\n\n\n\n\n\nWe can see that the first collision record (min) was on July 8, 2012 The last record (max), for this iteration is August 12, 2023.\n\n\nCode - Create a ‘start_date’ and an ‘end_date’ variable.\n# Create a 'start_date' and 'end_date' variable, which is useful for our charts\nstart_date = crash[\"DATE\"].dt.date.min()\nend_date = crash[\"DATE\"].dt.date.max()\n\nprint(\"Start Date: {0} - End Date: {1}\".format(start_date, end_date))\n\n\nStart Date: 2012-07-01 - End Date: 2023-08-12\n\n\n\n\n\nThe BOROUGH column contains the 5 boroughs of New York City, BROOKLYN, BRONX, MANHATTAN, QUEENS and STATEN ISLAND.\nUnfortunately, many of the ‘BOROUGH’ fields are empty.\nThe NYPD don’t record the borough in certain situations. For example, if the collision occurred on one of the main bridges between boroughs, or if the collision occurred on any one of NYC’s many expressways or parkways. Further investigation would be needed to confirm this.\nI previously reached out to the open data team for more information on this, but got no reply.\n\n\nCode - Replace empty ‘BOROUGH’ values with ‘UNKNOWN’\ncrash.fillna(value={\"BOROUGH\": \"UNKNOWN\"}, inplace=True)\ncrash[\"BOROUGH\"].describe()\n\n\ncount     2017370\nunique          6\ntop       UNKNOWN\nfreq       627585\nName: BOROUGH, dtype: object\n\n\n\n\n\n\nunique\n\nUnique borough name count, which includes the ‘UNKNOWN’ borough\n\ntop\n\n‘UNKNOWN’ is the most frequent borough recorded\n\nfreq\n\nTells us the occurrence of ‘UNKNOWN’ borough records\n\ncount\n\nHow many rows of data in the dataset\n\n\n\n\n\n\n\nCode - Replace empty ZIP_CODE’s with ‘UNKNOWN’\n# Replace empty ZIP_CODE's with 'UNKNOWN'\ncrash.fillna(value={\"ZIP_CODE\": \"UNKNOWN\"}, inplace=True)\ncrash[\"ZIP_CODE\"].describe()\n\n\ncount     2017370\nunique        235\ntop       UNKNOWN\nfreq       627823\nName: ZIP_CODE, dtype: object\n\n\n\n\n\nAs with the BOROUGH column, the postal ZIP_CODE is often left empty. In this case, using crash['ZIP_CODE'].describe(), we see that the ZIP_CODE with the most collisions, top, is 11207 in Brooklyn.\nThe freq gives a count of collisions for this zip code. 11207 has a large population, almost 80,000 people, which may account for these numbers. A future project would be to see how these zip code counts relate to their population. The unique number tells us that there are 234 NYC zip codes with recorded collisions in this dataset.\n\n\n\n\n\nCode - Create new columns, YEAR, MONTH_NAME, DAY_NAME and HOUR\n#  by extracting information from the *DATE* column\n\n# Set up some date columns: YEAR, MONTH_NAME, DAY_NAME, HOUR\n# Remove all records for 2012 as it's only a partial year.\n\ncrash[\"YEAR\"] = crash[\"DATE\"].dt.year\n\n# Get rid of 2012 as it only has 6 months of data\nno_2012_mask = crash[\"YEAR\"] &gt; 2012\ncrash = crash[no_2012_mask]\n\n# Reset the start_date variable to reflect the change\nstart_date = crash[\"DATE\"].dt.date.min()\nyear_order = crash[\"YEAR\"].sort_values().unique()\n\n# Create a MONTH_NAME column. Actually, month abbreviated name\ncrash[\"MONTH_NAME\"] = crash[\"DATE\"].dt.month_name().str[0:3]\n\n# Create a HOUR column, which reflects the hour of day that the collision occurred\ncrash[\"HOUR\"] = crash[\"DATE\"].dt.strftime(\"%H\")\n\n# Need to convert hour_order to a Python list instead of Numpy array\nhour_order = crash[\"HOUR\"].sort_values().unique().tolist()\n\ncrash[\"DAY_NAME\"] = crash[\"DATE\"].dt.strftime(\"%a\")\n\nprint(\"Year, Month and Hour order lists will be used for charting.\")\nprint(\"Year order: {}\\n\".format(year_order))\nprint(\"Month abbreviations: {}\\n\".format(crash.MONTH_NAME.unique()))\nprint(\"Hour order: {}\\n\".format(hour_order))\n\n\nYear, Month and Hour order lists will be used for charting.\nYear order: [2013 2014 2015 2016 2017 2018 2019 2020 2021 2022 2023]\n\nMonth abbreviations: ['Sep' 'Mar' 'Jun' 'Dec' 'Apr' 'Jul' 'Feb' 'Aug' 'Nov' 'May' 'Jan' 'Oct']\n\nHour order: ['00', '01', '02', '03', '04', '05', '06', '07', '08', '09', '10', '11', '12', '13', '14', '15', '16', '17', '18', '19', '20', '21', '22', '23']\n\n\n\n\n\n\n\nThis chart will give an overview of the total deaths and injuries on NYC roads.\n\n\n\nCode - Create the yearly Killed/Injured collections.\ncrash_by_year_killed = (\n    crash.groupby(\"YEAR\")[\"NUM_PERSONS_KILLED\"].sum().sort_values(ascending=False)\n)\ncrash_by_year_injured = (\n    crash.groupby(\"YEAR\")[\"NUM_PERSONS_INJURED\"].sum().sort_values(ascending=False)\n)\n\n\n\n\nCode - Create Matplotlib bar chart with yearly details on the number of people killed and injured.\nkilled_injured = {\n    \"Killed\": crash_by_year_killed.loc[year_order],\n    \"Injured\": crash_by_year_injured.loc[year_order],\n}\n\nx_loc = np.arange(len(year_order))  # the label locations\nwidth = 0.45  # the width of the bars\nmultiplier = 0\nfig, ax = plt.subplots(figsize=(10, 15), layout=\"constrained\")\n\n# Create the Injured/Killed bars for each year\nfor killed_or_injured, count in killed_injured.items():\n    offset = width * multiplier\n    rects = ax.bar(x_loc + offset, count, width, label=killed_or_injured)\n    ax.bar_label(rects, padding=3)\n    multiplier += 1\n\n# Add some text for labels, title and custom x-axis tick labels, etc.\nax.set_xlabel(\"Year\", fontsize=14)\nax.set_ylabel(\"Killed/Injured Count\", fontsize=14)\nax.set_title(\n    \"Persons Killed and Injured From {0} to {1}\".format(start_date, end_date),\n    fontsize=20,\n)\nax.set_xticks(x_loc + (width / 2), year_order)\nax.legend(loc=\"upper left\")\nax.set_yscale(\"log\")\nplt.show()\n\n\n\n\n\n\n\nThe chart shows that traffic fatalities had a general downward trend from the high of 297 in 2013 to a low of 231 in 2018. The trend is upwards from 2019 to 2021, which was just 1 off the worst year, 2013. For injuries, 2016 to 2019 were the worst. The following years are a slight improvement, but no visible downward trend yet.\n\n\n\n\nFor each category, Person, Pedestrian, Cyclist and Motorist there will be a new ‘CASUALTY’ column with the combined Injured/Killed values\nThe new columns are, PERSON_CASUALTY_COUNT, PEDESTRIAN_CASUALTY_COUNT, CYCLIST_CASUALTY_COUNT and MOTORIST_CASUALTY_COUNT\n\n\n\nCode - Combine the INJURED and KILLED columns into one ‘CASUALTIES’ column.\ncrash[\"PERSON_CASUALTY_COUNT\"] = crash.NUM_PERSONS_INJURED + crash.NUM_PERSONS_KILLED\ncrash[\"PEDESTRIAN_CASUALTY_COUNT\"] = (\n    crash.NUM_PEDESTRIANS_INJURED + crash.NUM_PEDESTRIANS_KILLED\n)\n\ncrash[\"CYCLIST_CASUALTY_COUNT\"] = crash.NUM_CYCLISTS_INJURED + crash.NUM_CYCLISTS_KILLED\ncrash[\"MOTORIST_CASUALTY_COUNT\"] = (\n    crash.NUM_MOTORISTS_INJURED + crash.NUM_MOTORISTS_KILLED\n)\n\nkilled_injured_mask = (crash.NUM_PERSONS_KILLED &gt; 0) & (crash.NUM_PERSONS_INJURED &gt; 0)\n\n\n\n\n\n\nA function to print value counts above or to the side of Barchart bars.\nI got the original function from this very useful site, statology.org.\nThe original function is here.\n\n\n\nCode - Function to print value counts above or to the side of barchart bars\ndef show_values(axs, orient=\"v\", space=0.01):\n    def _single(ax):\n        if orient == \"v\":\n            for p in ax.patches:\n                _x = p.get_x() + p.get_width() / 2\n                _y = p.get_y() + p.get_height() + (p.get_height() * 0.01)\n                value = \"{:6,.0f}\".format(p.get_height())\n                ax.text(_x, _y, value, ha=\"center\", fontsize=12)\n        elif orient == \"h\":\n            for p in ax.patches:\n                _x = p.get_x() + p.get_width() + float(space)\n                _y = p.get_y() + p.get_height() - (p.get_height() * 0.5)\n                value = \"{:6,.0f}\".format(p.get_width())\n                ax.text(_x, _y, value, ha=\"left\", fontsize=12)\n\n    if isinstance(axs, np.ndarray):\n        for idx, ax in np.ndenumerate(axs):\n            _single(ax)\n    else:\n        _single(axs)\n\n\n\n\nCode - Helper functions for creating multiple charts based on Grouped statistics.\n# Statistics will be created for the below columns.\n#   PERSON_CASUALTY_COUNT\n#   PEDESTRIAN_CASUALTY_COUNT\n#   CYCLIST_CASUALTY_COUNT\n#   MOTORIST_CASUALTY_COUNT\n\n\ndef create_grouped_casualty_data_by_category(\n    victim_categories, time_group=\"YEAR\", order_list=None\n):\n    \"\"\"\n    Create multiple Seaborn SubPlot charts based on:\n    PERSON_CASUALTY_COUNT, PEDESTRIAN_CASUALTY_COUNT, CYCLIST_CASUALTY_COUNT and MOTORIST_CASUALTY_COUNT\n    time_group can be 'HOUR', 'DAY_OF_WEEK', 'MONTH_NAME', 'YEAR'\n    \"\"\"\n    time_group = time_group.upper()\n    all_casualty_data = []\n\n    for category in victim_categories:\n        cat_upper = category.upper()\n        casualty_label = cat_upper + \"_CASUALTY_COUNT\"\n\n        casualty_data = crash.groupby(by=[time_group], as_index=True).agg(\n            {casualty_label: \"sum\"}\n        )\n        if order_list and len(order_list):\n            casualty_data = casualty_data.loc[order_list]\n\n        category_data = {\n            \"category\": category,\n            \"casualty_label\": casualty_label,\n            \"casualty_data\": casualty_data,\n        }\n\n        all_casualty_data.append(category_data)\n    return all_casualty_data\n\n\ndef create_bar_plots_for_casualty_data(sns, axes, order_list, crash_victims_data):\n    for idx, category_data in enumerate(crash_victims_data):\n        xlabel = None\n        ylabel = None\n        # Casualty Chart\n        category_title = category_data[\"category\"].title()\n        chart_title = \"{0} Casualties\".format(category_title)\n\n        casualty_max = category_data[\"casualty_data\"][\n            category_data[\"casualty_label\"]\n        ].max()\n        casualty_values = category_data[\"casualty_data\"][\n            category_data[\"casualty_label\"]\n        ].to_list()\n\n        casualty_colors = [\n            \"k\" if (x &gt;= casualty_max) else \"tab:red\" for x in casualty_values\n        ]\n\n        ax = axes[idx]\n\n        sns.barplot(\n            data=category_data[\"casualty_data\"],\n            x=order_list,\n            order=order_list,\n            y=category_data[\"casualty_label\"],\n            palette=casualty_colors,\n            ax=ax,\n        ).set(title=chart_title, xlabel=xlabel, ylabel=ylabel)\n\n        show_values(axes)\n\n\n\n\nCode - Set some global Matplotlib/Seaborn chart variables.\ntitle_fontsize = 20\nlabel_fontsize = 18\n# For spacing between charts on the same grid\ngridspec_kw = {\"wspace\": 0.1, \"hspace\": 0.1}\n\nsns.set_style(\"whitegrid\")\n\n\n\n\n\n\n\n2018 was the worst for human casualties, with 62,172 injuries and deaths. 2019 was a close second, followed by 2017 and 2016.\n\nCyclists - 2020 was by far the worst year with 5,605 casualties.\nMotorists - 2018 was their worst year with 46,168 casualties.\nPedestrians - 2013 was their worst year with 12,164 casualties. Things have improved a little for them since then.\n\n\n\nCode - Create Seaborn charts for crash casualties based on year.\ncol_ct = 1\n#  Create the outer figure box\nfig, axes = plt.subplots(\n    4, col_ct, figsize=(15, 40), layout=\"constrained\", gridspec_kw=gridspec_kw\n)\nfig.suptitle(\n    \"Total Yearly Crash Casualties from {0} to {1} by Category\".format(\n        start_date, end_date\n    ),\n    fontsize=title_fontsize,\n)\nfig.supxlabel(\"Year\", fontsize=label_fontsize)\nfig.supylabel(\"Counts\", fontsize=label_fontsize)\n\ncrash_casualty_data = create_grouped_casualty_data_by_category(\n    victim_categories, \"year\"\n)\ncreate_bar_plots_for_casualty_data(sns, axes, year_order, crash_casualty_data)\n\n\n\n\n\n\n\n\nJune has been the worst month for human casualties, with 56,240 injuries and deaths.\nThe Summer months in general seem to be bad for motorists and cyclists, while winter is bad for pedestrians.\n\nCyclists - July has been the worst, with 6,270 casualties. August and June follow after that.\nMotorists - July has been the worst, with 41,140 casualties. June is a close second.\nPedestrians - December has been the worst, with 10,750 casualties. January is a close second.\n\nWinter time may be a good time to stay on public transport or indoors.\n\n\n\n\nCode - Create Seaborn charts for crash casualties based on month.\n# Create the outer figure box\ncol_ct = 1\nfig, axes = plt.subplots(\n    4, col_ct, figsize=(20, 30), layout=\"constrained\", gridspec_kw=gridspec_kw\n)\n\nfig.suptitle(\n    \"Total Monthly Crash Casualties from {0} to {1} by Category\".format(\n        start_date, end_date\n    ),\n    fontsize=title_fontsize,\n)\nfig.supxlabel(\"Month\", fontsize=label_fontsize)\nfig.supylabel(\"Counts\", fontsize=label_fontsize)\n\ncrash_casualty_data = create_grouped_casualty_data_by_category(\n    victim_categories, \"month_name\", month_abbr_order\n)\ncreate_bar_plots_for_casualty_data(sns, axes, month_abbr_order, crash_casualty_data)\n\n\n\n\n\n\n\n\nFriday tends to be the worst day for human casualties, with 90,089 injuries and deaths. Sunday seems to be the safest.\n\nCyclists - Friday is a bad day to bike in NYC, with 8,008 casualties since the start of 2013.\nMotorists - Friday and Saturday are equally bad, with 63,774 casualties each.\nPedestrians - Pedestrians should also avoid Fridays, with 17,337 casualties since the start of 2013.\n\n\n\nCode - Create Seaborn charts for crash casualties based on day of the week.\ncol_ct = 1\nfig, axes = plt.subplots(\n    4, col_ct, figsize=(15, 40), layout=\"constrained\", gridspec_kw=gridspec_kw\n)\n\nfig.suptitle(\n    \"Total Day of Week Crash Casualties from {0} to {1} by Category\".format(\n        start_date, end_date\n    ),\n    fontsize=title_fontsize,\n)\nfig.supxlabel(\"Day of Week\", fontsize=label_fontsize)\nfig.supylabel(\"Counts\", fontsize=label_fontsize)\n\n# crash.set_index('MONTH_NAME').loc[month_abbr_order].groupby(by=['MONTH_NAME']).agg({'PEDESTRIAN_CASUALTY_COUNT': 'sum'}).plot(kind='bar')\ncrash_casualty_data = create_grouped_casualty_data_by_category(\n    victim_categories, \"day_name\", day_abbr_order\n)\ncrash_casualty_data\ncreate_bar_plots_for_casualty_data(sns, axes, day_abbr_order, crash_casualty_data)\n\n\n\n\n\n\n\n\nThe hour between 5 and 6 pm is the worst time for human casualties, with 40,777 injuries and deaths. The rush-hour times around 5 pm have a high casualty count. The morning rush hour also trends higher, but much lower than the evening rush-hour.\nThe early hours of the morning between 12 and 1 am also having a high body count. This is at a time when you would expect the traffic volume to be low.\n\nCyclists - Follow the trend with 4,167 casualties between 5 and 6 pm.\nMotorists - Get off to an earlier start, with 28,142 casualties between 4 and 5 pm.\nPedestrians - Pedestrians get hit at higher rates between 5 and 6 pm, with 8,6623 casualties since the start of 2013.\n\n\n\nCode - Create Seaborn charts for crash casualties based on the Hour of day.\n#  Create the outer figure box\ncol_ct = 1\nfig, axes = plt.subplots(\n    4, col_ct, figsize=(15, 40), layout=\"constrained\", gridspec_kw=gridspec_kw\n)\n\nfig.suptitle(\n    \"Total Hour of Day Crash Casualties from {0} to {1} by Category\".format(\n        start_date, end_date\n    ),\n    fontsize=title_fontsize,\n)\nfig.supxlabel(\"Hour of Day\", fontsize=label_fontsize)\nfig.supylabel(\"Counts\", fontsize=label_fontsize)\n\ncrash_casualty_data = create_grouped_casualty_data_by_category(\n    victim_categories, \"hour\", hour_order\n)\n\n#  Create the inner charts\ncreate_bar_plots_for_casualty_data(sns, axes, hour_order, crash_casualty_data)"
  },
  {
    "objectID": "crash_time_period_stats.html#what-time-of-day",
    "href": "crash_time_period_stats.html#what-time-of-day",
    "title": "NYC Collision Data Analysis",
    "section": "…what time of day?",
    "text": "…what time of day?"
  },
  {
    "objectID": "crash_time_period_stats.html#what-month-of-the-year",
    "href": "crash_time_period_stats.html#what-month-of-the-year",
    "title": "NYC Collision Data Analysis",
    "section": "…what month of the year?",
    "text": "…what month of the year?"
  },
  {
    "objectID": "crash_time_period_stats.html#has-the-most-human-casualties-on-new-yorks-streets",
    "href": "crash_time_period_stats.html#has-the-most-human-casualties-on-new-yorks-streets",
    "title": "NYC Collision Data Analysis",
    "section": "Has the most human casualties on New York’s streets?",
    "text": "Has the most human casualties on New York’s streets?\n\nPeak times for traffic related casualties in New York City\nUsing the open traffic collisions data available from NYPD.\nYou can skip the explanations and go straight to the results.\nOr, you can read on and see how I came up with these numbers using Python and the pandas library.\n\n\nCode - Import All Required Python Modules\nimport datetime\nfrom pathlib import Path\n\nimport matplotlib.pyplot as plt\n\n# Import All Required Python Modules\nimport numpy as np\nimport pandas as pd\nimport seaborn as sns\n\n\n\n\nCode - Data Formatting Functions\n# Data Formatting Functions\n\n\ndef empty_to_zero(val):\n    \"\"\"Converts empty values to 0\"\"\"\n    val = val.strip(\"\\s+\")\n    return val if len(val) else 0\n\n\ndef convert_to_numeric(df, column_list):\n    \"\"\"Given a list of DataFrame columns, it converts the empty values to zero\"\"\"\n    df[column_list] = df[column_list].apply(pd.to_numeric, errors=\"coerce\")\n\n\n\n\nCode - Set Up Some Global Variables\n# Set Up Some Global Variables\n\n# I'm omitting longitude, latitude, the vehicle types as well as crash contributing factors.\ncols_requested = [\n    \"COLLISION_ID\",\n    \"CRASH DATE\",\n    \"CRASH TIME\",\n    \"BOROUGH\",\n    \"ZIP CODE\",\n    \"LOCATION\",\n    \"ON STREET NAME\",\n    \"CROSS STREET NAME\",\n    \"OFF STREET NAME\",\n    \"NUMBER OF PERSONS INJURED\",\n    \"NUMBER OF PERSONS KILLED\",\n    \"NUMBER OF PEDESTRIANS INJURED\",\n    \"NUMBER OF PEDESTRIANS KILLED\",\n    \"NUMBER OF CYCLIST INJURED\",\n    \"NUMBER OF CYCLIST KILLED\",\n    \"NUMBER OF MOTORIST INJURED\",\n    \"NUMBER OF MOTORIST KILLED\",\n]\n\n# To ensure that the colums are of the expected data type\ncrash_dtypes = {\n    \"CRASH DATE\": str,\n    \"CRASH TIME\": str,\n    \"BOROUGH\": str,\n    \"ZIP CODE\": str,\n    \"LOCATION\": str,\n    \"ON STREET NAME\": str,\n    \"CROSS STREET NAME\": str,\n    \"OFF STREET NAME\": str,\n}\n\n# Rename some colums to ones that I believe are shorter and/or more meaningful\ncols_rename = {\n    \"CRASH DATE\": \"DATE\",\n    \"CRASH TIME\": \"TIME\",\n    \"ZIP CODE\": \"ZIP_CODE\",\n    \"ON STREET NAME\": \"ON_STREET_NAME\",\n    \"CROSS STREET NAME\": \"CROSS_STREET_NAME\",\n    \"OFF STREET NAME\": \"OFF_STREET_NAME\",\n    \"NUMBER OF PERSONS INJURED\": \"NUM_PERSONS_INJURED\",\n    \"NUMBER OF PERSONS KILLED\": \"NUM_PERSONS_KILLED\",\n    \"NUMBER OF PEDESTRIANS INJURED\": \"NUM_PEDESTRIANS_INJURED\",\n    \"NUMBER OF PEDESTRIANS KILLED\": \"NUM_PEDESTRIANS_KILLED\",\n    \"NUMBER OF CYCLIST INJURED\": \"NUM_CYCLISTS_INJURED\",\n    \"NUMBER OF CYCLIST KILLED\": \"NUM_CYCLISTS_KILLED\",\n    \"NUMBER OF MOTORIST INJURED\": \"NUM_MOTORISTS_INJURED\",\n    \"NUMBER OF MOTORIST KILLED\": \"NUM_MOTORISTS_KILLED\",\n}\n\n# Columns that contain numeric values\nnumeric_cols = [\n    \"NUM_PERSONS_INJURED\",\n    \"NUM_PERSONS_KILLED\",\n    \"NUM_PEDESTRIANS_INJURED\",\n    \"NUM_PEDESTRIANS_KILLED\",\n    \"NUM_CYCLISTS_INJURED\",\n    \"NUM_CYCLISTS_KILLED\",\n    \"NUM_MOTORISTS_INJURED\",\n    \"NUM_MOTORISTS_KILLED\",\n]\n\n# These ordered lists are useful for plotting charts\nday_names_order = [\n    \"Monday\",\n    \"Tuesday\",\n    \"Wednesday\",\n    \"Thursday\",\n    \"Friday\",\n    \"Saturday\",\n    \"Sunday\",\n]\nday_abbr_order = [d[0:3] for d in day_names_order]\nmonth_names_order = [\n    \"January\",\n    \"February\",\n    \"March\",\n    \"April\",\n    \"May\",\n    \"June\",\n    \"July\",\n    \"August\",\n    \"September\",\n    \"October\",\n    \"November\",\n    \"December\",\n]\nmonth_abbr_order = [m[0:3] for m in month_names_order]\n\n# The following DataFrame columns that will have their empty values converted to zero using the\n# 'empty_to_zero' function\nconvert_cols = {\n    \"NUMBER OF PERSONS INJURED\": empty_to_zero,\n    \"NUMBER OF PERSONS KILLED\": empty_to_zero,\n    \"NUMBER OF PEDESTRIANS INJURED\": empty_to_zero,\n    \"NUMBER OF PEDESTRIANS KILLED\": empty_to_zero,\n    \"NUMBER OF CYCLIST INJURED\": empty_to_zero,\n    \"NUMBER OF CYCLIST KILLED\": empty_to_zero,\n    \"NUMBER OF MOTORIST INJURED\": empty_to_zero,\n    \"NUMBER OF MOTORIST KILLED\": empty_to_zero,\n}\n\n# These are the 4 categories supplied by the NYPD\nvictim_categories = [\"person\", \"cyclist\", \"motorist\", \"pedestrian\"]\n# 'person' status should be a combination of the other three categories\n# TODO I need to verify the relationship between 'person' and the other three categories\n\n# These are the Matplotlib Tableau colors\nbar_colors = [\n    \"tab:blue\",\n    \"tab:orange\",\n    \"tab:green\",\n    \"tab:red\",\n    \"tab:purple\",\n    \"tab:brown\",\n    \"tab:pink\",\n    \"tab:gray\",\n    \"tab:olive\",\n    \"tab:cyan\",\n]\n\nbase_colors = [\"b\", \"g\", \"r\", \"c\", \"m\", \"y\", \"k\", \"w\"]\n\n# Chart Colors\ncolor = \"k\"\nplt.rcParams[\"text.color\"] = color\nplt.rcParams[\"axes.labelcolor\"] = color\nplt.rcParams[\"xtick.color\"] = \"b\"\nplt.rcParams[\"ytick.color\"] = \"b\"\n\n\n\nRead the NYC collision data CSV file into our Pandas DataFrame, ‘crash’.\n\nThe Collision Dataset provided by NYPD is available here.\n\n\n\nCode - Creating the ‘crash’ DataFrame from the NYPD CSV file.\ncollision_filename = \"Motor_Vehicle_Collisions_Aug15_2023.csv\"\n\n# Using the Pandas 'read_csv' function\ncrash = pd.read_csv(\n    Path.cwd().joinpath(\"..\").joinpath(collision_filename),\n    index_col=\"COLLISION_ID\",\n    usecols=cols_requested,\n    dtype=crash_dtypes,\n    converters=convert_cols,\n)\n\n\n\n\nRename some of the DataFrame columns\noriginal_col_names = crash.columns.to_list()\n\n# Rename the columns using the list of new names, 'cols_rename'\ncrash.rename(columns=cols_rename, inplace=True)\n\nprint(\"Original Crash Column Names\\n{}\".format(original_col_names))\nprint(\"\\nRenamed Crash Columns Names\\n{}\".format(crash.columns.to_list()))\n\n\nOriginal Crash Column Names\n['CRASH DATE', 'CRASH TIME', 'BOROUGH', 'ZIP CODE', 'LOCATION', 'ON STREET NAME', 'CROSS STREET NAME', 'OFF STREET NAME', 'NUMBER OF PERSONS INJURED', 'NUMBER OF PERSONS KILLED', 'NUMBER OF PEDESTRIANS INJURED', 'NUMBER OF PEDESTRIANS KILLED', 'NUMBER OF CYCLIST INJURED', 'NUMBER OF CYCLIST KILLED', 'NUMBER OF MOTORIST INJURED', 'NUMBER OF MOTORIST KILLED']\n\nRenamed Crash Columns Names\n['DATE', 'TIME', 'BOROUGH', 'ZIP_CODE', 'LOCATION', 'ON_STREET_NAME', 'CROSS_STREET_NAME', 'OFF_STREET_NAME', 'NUM_PERSONS_INJURED', 'NUM_PERSONS_KILLED', 'NUM_PEDESTRIANS_INJURED', 'NUM_PEDESTRIANS_KILLED', 'NUM_CYCLISTS_INJURED', 'NUM_CYCLISTS_KILLED', 'NUM_MOTORISTS_INJURED', 'NUM_MOTORISTS_KILLED']\n\n\n\n\nCode - Convert string values to numeric for specific ‘numeric’ columns.\n# Ensure that the 'numeric_cols' column values are numeric and not string values\nconvert_to_numeric(crash, numeric_cols)\n\n\n\n\nCode - General Description of the ‘crash’ dataset\n#  General Description of the dataset.\n\n# The 'set_option' is used here to display numeric values as a 'float' rather\n# than the default scientific notation\npd.set_option(\"display.float_format\", lambda x: \"%8.2f\" % x)\ncrash.describe()\n\n\n\n\n\n\n\n\n\nNUM_PERSONS_INJURED\nNUM_PERSONS_KILLED\nNUM_PEDESTRIANS_INJURED\nNUM_PEDESTRIANS_KILLED\nNUM_CYCLISTS_INJURED\nNUM_CYCLISTS_KILLED\nNUM_MOTORISTS_INJURED\nNUM_MOTORISTS_KILLED\n\n\n\n\ncount\n2017370.00\n2017370.00\n2017370.00\n2017370.00\n2017370.00\n2017370.00\n2017370.00\n2017370.00\n\n\nmean\n0.30\n0.00\n0.06\n0.00\n0.03\n0.00\n0.22\n0.00\n\n\nstd\n0.69\n0.04\n0.24\n0.03\n0.16\n0.01\n0.65\n0.03\n\n\nmin\n0.00\n0.00\n0.00\n0.00\n0.00\n0.00\n0.00\n0.00\n\n\n25%\n0.00\n0.00\n0.00\n0.00\n0.00\n0.00\n0.00\n0.00\n\n\n50%\n0.00\n0.00\n0.00\n0.00\n0.00\n0.00\n0.00\n0.00\n\n\n75%\n0.00\n0.00\n0.00\n0.00\n0.00\n0.00\n0.00\n0.00\n\n\nmax\n43.00\n8.00\n27.00\n6.00\n4.00\n2.00\n43.00\n5.00\n\n\n\n\n\n\n\n\n\ncrash.describe()\nThe count tells us that there are over 2M rows of data. The maximum(max) NUM_PERSONS_INJURED in one collision is 43.\nThe average(mean) NUM_PERSONS_INJURED per collision is 0.3, or almost 1 for every three collisions. You can find more details on the pandas.DataFrame.describe function here.\n\n\nMerge the ‘DATE’ and ‘TIME’ columns into one ‘DATE’ column.\n\nThe original ‘DATE’ is a “date only” field without the time. After merging the date and time columns, convert ‘DATE’ to a Python “datetime” object. Then remove the now unnecessary ‘TIME’ column.\n\n\n\nCode - Combine the DATE and TIME columns into the DATE column\n# Merge\ncrash[\"DATE\"] = pd.to_datetime(crash[\"DATE\"] + \" \" + crash[\"TIME\"])\n# Remove the 'TIME' column\ncrash.drop(columns=[\"TIME\"], inplace=True)\n# Convert to Python 'datetime'\ncrash[\"DATE\"] = pd.to_datetime(crash[\"DATE\"])\n\n\n\ncrash[\"DATE\"].describe()\n\ncount                          2017370\nmean     2017-05-13 17:54:54.650598912\nmin                2012-07-01 00:05:00\n25%                2014-12-19 13:00:15\n50%                2017-03-29 10:07:30\n75%                2019-06-09 17:50:00\nmax                2023-08-12 23:56:00\nName: DATE, dtype: object\n\n\n\n\ncrash['DATE'].describe()\nWe can see that the first collision record (min) was on July 8, 2012 The last record (max), for this iteration is August 12, 2023.\n\n\nCode - Create a ‘start_date’ and an ‘end_date’ variable.\n# Create a 'start_date' and 'end_date' variable, which is useful for our charts\nstart_date = crash[\"DATE\"].dt.date.min()\nend_date = crash[\"DATE\"].dt.date.max()\n\nprint(\"Start Date: {0} - End Date: {1}\".format(start_date, end_date))\n\n\nStart Date: 2012-07-01 - End Date: 2023-08-12\n\n\n\n\nThe ‘UNKNOWN’ Borough\nThe BOROUGH column contains the 5 boroughs of New York City, BROOKLYN, BRONX, MANHATTAN, QUEENS and STATEN ISLAND.\nUnfortunately, many of the ‘BOROUGH’ fields are empty.\nThe NYPD don’t record the borough in certain situations. For example, if the collision occurred on one of the main bridges between boroughs, or if the collision occurred on any one of NYC’s many expressways or parkways. Further investigation would be needed to confirm this.\nI previously reached out to the open data team for more information on this, but got no reply.\n\n\nCode - Replace empty ‘BOROUGH’ values with ‘UNKNOWN’\ncrash.fillna(value={\"BOROUGH\": \"UNKNOWN\"}, inplace=True)\ncrash[\"BOROUGH\"].describe()\n\n\ncount     2017370\nunique          6\ntop       UNKNOWN\nfreq       627585\nName: BOROUGH, dtype: object\n\n\n\n\ncrash['BOROUGH'].describe() provides some useful information.\n\nunique\n\nUnique borough name count, which includes the ‘UNKNOWN’ borough\n\ntop\n\n‘UNKNOWN’ is the most frequent borough recorded\n\nfreq\n\nTells us the occurrence of ‘UNKNOWN’ borough records\n\ncount\n\nHow many rows of data in the dataset\n\n\n\n\nZIP_CODE\n\n\nCode - Replace empty ZIP_CODE’s with ‘UNKNOWN’\n# Replace empty ZIP_CODE's with 'UNKNOWN'\ncrash.fillna(value={\"ZIP_CODE\": \"UNKNOWN\"}, inplace=True)\ncrash[\"ZIP_CODE\"].describe()\n\n\ncount     2017370\nunique        235\ntop       UNKNOWN\nfreq       627823\nName: ZIP_CODE, dtype: object\n\n\n\n\ncrash['ZIP_CODE'].describe()\nAs with the BOROUGH column, the postal ZIP_CODE is often left empty. In this case, using crash['ZIP_CODE'].describe(), we see that the ZIP_CODE with the most collisions, top, is 11207 in Brooklyn.\nThe freq gives a count of collisions for this zip code. 11207 has a large population, almost 80,000 people, which may account for these numbers. A future project would be to see how these zip code counts relate to their population. The unique number tells us that there are 234 NYC zip codes with recorded collisions in this dataset.\n\n\nCreate some new columns, YEAR, MONTH_NAME, DAY_NAME and HOUR\n\n\nCode - Create new columns, YEAR, MONTH_NAME, DAY_NAME and HOUR\n#  by extracting information from the *DATE* column\n\n# Set up some date columns: YEAR, MONTH_NAME, DAY_NAME, HOUR\n# Remove all records for 2012 as it's only a partial year.\n\ncrash[\"YEAR\"] = crash[\"DATE\"].dt.year\n\n# Get rid of 2012 as it only has 6 months of data\nno_2012_mask = crash[\"YEAR\"] &gt; 2012\ncrash = crash[no_2012_mask]\n\n# Reset the start_date variable to reflect the change\nstart_date = crash[\"DATE\"].dt.date.min()\nyear_order = crash[\"YEAR\"].sort_values().unique()\n\n# Create a MONTH_NAME column. Actually, month abbreviated name\ncrash[\"MONTH_NAME\"] = crash[\"DATE\"].dt.month_name().str[0:3]\n\n# Create a HOUR column, which reflects the hour of day that the collision occurred\ncrash[\"HOUR\"] = crash[\"DATE\"].dt.strftime(\"%H\")\n\n# Need to convert hour_order to a Python list instead of Numpy array\nhour_order = crash[\"HOUR\"].sort_values().unique().tolist()\n\ncrash[\"DAY_NAME\"] = crash[\"DATE\"].dt.strftime(\"%a\")\n\nprint(\"Year, Month and Hour order lists will be used for charting.\")\nprint(\"Year order: {}\\n\".format(year_order))\nprint(\"Month abbreviations: {}\\n\".format(crash.MONTH_NAME.unique()))\nprint(\"Hour order: {}\\n\".format(hour_order))\n\n\nYear, Month and Hour order lists will be used for charting.\nYear order: [2013 2014 2015 2016 2017 2018 2019 2020 2021 2022 2023]\n\nMonth abbreviations: ['Sep' 'Mar' 'Jun' 'Dec' 'Apr' 'Jul' 'Feb' 'Aug' 'Nov' 'May' 'Jan' 'Oct']\n\nHour order: ['00', '01', '02', '03', '04', '05', '06', '07', '08', '09', '10', '11', '12', '13', '14', '15', '16', '17', '18', '19', '20', '21', '22', '23']\n\n\n\n\n\nChart the Yearly Collision Injuries and Deaths\n\nThis chart will give an overview of the total deaths and injuries on NYC roads.\n\n\n\nCode - Create the yearly Killed/Injured collections.\ncrash_by_year_killed = (\n    crash.groupby(\"YEAR\")[\"NUM_PERSONS_KILLED\"].sum().sort_values(ascending=False)\n)\ncrash_by_year_injured = (\n    crash.groupby(\"YEAR\")[\"NUM_PERSONS_INJURED\"].sum().sort_values(ascending=False)\n)\n\n\n\n\nCode - Create Matplotlib bar chart with yearly details on the number of people killed and injured.\nkilled_injured = {\n    \"Killed\": crash_by_year_killed.loc[year_order],\n    \"Injured\": crash_by_year_injured.loc[year_order],\n}\n\nx_loc = np.arange(len(year_order))  # the label locations\nwidth = 0.45  # the width of the bars\nmultiplier = 0\nfig, ax = plt.subplots(figsize=(10, 15), layout=\"constrained\")\n\n# Create the Injured/Killed bars for each year\nfor killed_or_injured, count in killed_injured.items():\n    offset = width * multiplier\n    rects = ax.bar(x_loc + offset, count, width, label=killed_or_injured)\n    ax.bar_label(rects, padding=3)\n    multiplier += 1\n\n# Add some text for labels, title and custom x-axis tick labels, etc.\nax.set_xlabel(\"Year\", fontsize=14)\nax.set_ylabel(\"Killed/Injured Count\", fontsize=14)\nax.set_title(\n    \"Persons Killed and Injured From {0} to {1}\".format(start_date, end_date),\n    fontsize=20,\n)\nax.set_xticks(x_loc + (width / 2), year_order)\nax.legend(loc=\"upper left\")\nax.set_yscale(\"log\")\nplt.show()\n\n\n\n\n\n\nCollision Injuries and Deaths since 2013\nThe chart shows that traffic fatalities had a general downward trend from the high of 297 in 2013 to a low of 231 in 2018. The trend is upwards from 2019 to 2021, which was just 1 off the worst year, 2013. For injuries, 2016 to 2019 were the worst. The following years are a slight improvement, but no visible downward trend yet.\n\n\nCombine Killed + Injured Counts into one ‘CASUALTIES’ column\n\nFor each category, Person, Pedestrian, Cyclist and Motorist there will be a new ‘CASUALTY’ column with the combined Injured/Killed values\nThe new columns are, PERSON_CASUALTY_COUNT, PEDESTRIAN_CASUALTY_COUNT, CYCLIST_CASUALTY_COUNT and MOTORIST_CASUALTY_COUNT\n\n\n\nCode - Combine the INJURED and KILLED columns into one ‘CASUALTIES’ column.\ncrash[\"PERSON_CASUALTY_COUNT\"] = crash.NUM_PERSONS_INJURED + crash.NUM_PERSONS_KILLED\ncrash[\"PEDESTRIAN_CASUALTY_COUNT\"] = (\n    crash.NUM_PEDESTRIANS_INJURED + crash.NUM_PEDESTRIANS_KILLED\n)\n\ncrash[\"CYCLIST_CASUALTY_COUNT\"] = crash.NUM_CYCLISTS_INJURED + crash.NUM_CYCLISTS_KILLED\ncrash[\"MOTORIST_CASUALTY_COUNT\"] = (\n    crash.NUM_MOTORISTS_INJURED + crash.NUM_MOTORISTS_KILLED\n)\n\nkilled_injured_mask = (crash.NUM_PERSONS_KILLED &gt; 0) & (crash.NUM_PERSONS_INJURED &gt; 0)\n\n\n\n\nFunction show_values\n\nA function to print value counts above or to the side of Barchart bars.\nI got the original function from this very useful site, statology.org.\nThe original function is here.\n\n\n\nCode - Function to print value counts above or to the side of barchart bars\ndef show_values(axs, orient=\"v\", space=0.01):\n    def _single(ax):\n        if orient == \"v\":\n            for p in ax.patches:\n                _x = p.get_x() + p.get_width() / 2\n                _y = p.get_y() + p.get_height() + (p.get_height() * 0.01)\n                value = \"{:6,.0f}\".format(p.get_height())\n                ax.text(_x, _y, value, ha=\"center\", fontsize=12)\n        elif orient == \"h\":\n            for p in ax.patches:\n                _x = p.get_x() + p.get_width() + float(space)\n                _y = p.get_y() + p.get_height() - (p.get_height() * 0.5)\n                value = \"{:6,.0f}\".format(p.get_width())\n                ax.text(_x, _y, value, ha=\"left\", fontsize=12)\n\n    if isinstance(axs, np.ndarray):\n        for idx, ax in np.ndenumerate(axs):\n            _single(ax)\n    else:\n        _single(axs)\n\n\n\n\nCode - Helper functions for creating multiple charts based on Grouped statistics.\n# Statistics will be created for the below columns.\n#   PERSON_CASUALTY_COUNT\n#   PEDESTRIAN_CASUALTY_COUNT\n#   CYCLIST_CASUALTY_COUNT\n#   MOTORIST_CASUALTY_COUNT\n\n\ndef create_grouped_casualty_data_by_category(\n    victim_categories, time_group=\"YEAR\", order_list=None\n):\n    \"\"\"\n    Create multiple Seaborn SubPlot charts based on:\n    PERSON_CASUALTY_COUNT, PEDESTRIAN_CASUALTY_COUNT, CYCLIST_CASUALTY_COUNT and MOTORIST_CASUALTY_COUNT\n    time_group can be 'HOUR', 'DAY_OF_WEEK', 'MONTH_NAME', 'YEAR'\n    \"\"\"\n    time_group = time_group.upper()\n    all_casualty_data = []\n\n    for category in victim_categories:\n        cat_upper = category.upper()\n        casualty_label = cat_upper + \"_CASUALTY_COUNT\"\n\n        casualty_data = crash.groupby(by=[time_group], as_index=True).agg(\n            {casualty_label: \"sum\"}\n        )\n        if order_list and len(order_list):\n            casualty_data = casualty_data.loc[order_list]\n\n        category_data = {\n            \"category\": category,\n            \"casualty_label\": casualty_label,\n            \"casualty_data\": casualty_data,\n        }\n\n        all_casualty_data.append(category_data)\n    return all_casualty_data\n\n\ndef create_bar_plots_for_casualty_data(sns, axes, order_list, crash_victims_data):\n    for idx, category_data in enumerate(crash_victims_data):\n        xlabel = None\n        ylabel = None\n        # Casualty Chart\n        category_title = category_data[\"category\"].title()\n        chart_title = \"{0} Casualties\".format(category_title)\n\n        casualty_max = category_data[\"casualty_data\"][\n            category_data[\"casualty_label\"]\n        ].max()\n        casualty_values = category_data[\"casualty_data\"][\n            category_data[\"casualty_label\"]\n        ].to_list()\n\n        casualty_colors = [\n            \"k\" if (x &gt;= casualty_max) else \"tab:red\" for x in casualty_values\n        ]\n\n        ax = axes[idx]\n\n        sns.barplot(\n            data=category_data[\"casualty_data\"],\n            x=order_list,\n            order=order_list,\n            y=category_data[\"casualty_label\"],\n            palette=casualty_colors,\n            ax=ax,\n        ).set(title=chart_title, xlabel=xlabel, ylabel=ylabel)\n\n        show_values(axes)\n\n\n\n\nCode - Set some global Matplotlib/Seaborn chart variables.\ntitle_fontsize = 20\nlabel_fontsize = 18\n# For spacing between charts on the same grid\ngridspec_kw = {\"wspace\": 0.1, \"hspace\": 0.1}\n\nsns.set_style(\"whitegrid\")\n\n\n\n\n\n\nWhat was the worst year for traffic collision casualties?\n2018 was the worst for human casualties, with 62,172 injuries and deaths. 2019 was a close second, followed by 2017 and 2016.\n\nCyclists - 2020 was by far the worst year with 5,605 casualties.\nMotorists - 2018 was their worst year with 46,168 casualties.\nPedestrians - 2013 was their worst year with 12,164 casualties. Things have improved a little for them since then.\n\n\n\nCode - Create Seaborn charts for crash casualties based on year.\ncol_ct = 1\n#  Create the outer figure box\nfig, axes = plt.subplots(\n    4, col_ct, figsize=(15, 40), layout=\"constrained\", gridspec_kw=gridspec_kw\n)\nfig.suptitle(\n    \"Total Yearly Crash Casualties from {0} to {1} by Category\".format(\n        start_date, end_date\n    ),\n    fontsize=title_fontsize,\n)\nfig.supxlabel(\"Year\", fontsize=label_fontsize)\nfig.supylabel(\"Counts\", fontsize=label_fontsize)\n\ncrash_casualty_data = create_grouped_casualty_data_by_category(\n    victim_categories, \"year\"\n)\ncreate_bar_plots_for_casualty_data(sns, axes, year_order, crash_casualty_data)\n\n\n\n\n\n\n\nWhat are the worst months for traffic collision casualties?\nJune has been the worst month for human casualties, with 56,240 injuries and deaths.\nThe Summer months in general seem to be bad for motorists and cyclists, while winter is bad for pedestrians.\n\nCyclists - July has been the worst, with 6,270 casualties. August and June follow after that.\nMotorists - July has been the worst, with 41,140 casualties. June is a close second.\nPedestrians - December has been the worst, with 10,750 casualties. January is a close second.\n\nWinter time may be a good time to stay on public transport or indoors.\n\n\n\n\nCode - Create Seaborn charts for crash casualties based on month.\n# Create the outer figure box\ncol_ct = 1\nfig, axes = plt.subplots(\n    4, col_ct, figsize=(20, 30), layout=\"constrained\", gridspec_kw=gridspec_kw\n)\n\nfig.suptitle(\n    \"Total Monthly Crash Casualties from {0} to {1} by Category\".format(\n        start_date, end_date\n    ),\n    fontsize=title_fontsize,\n)\nfig.supxlabel(\"Month\", fontsize=label_fontsize)\nfig.supylabel(\"Counts\", fontsize=label_fontsize)\n\ncrash_casualty_data = create_grouped_casualty_data_by_category(\n    victim_categories, \"month_name\", month_abbr_order\n)\ncreate_bar_plots_for_casualty_data(sns, axes, month_abbr_order, crash_casualty_data)\n\n\n\n\n\n\n\nWhat day of the week should you avoid going out?\nFriday tends to be the worst day for human casualties, with 90,089 injuries and deaths. Sunday seems to be the safest.\n\nCyclists - Friday is a bad day to bike in NYC, with 8,008 casualties since the start of 2013.\nMotorists - Friday and Saturday are equally bad, with 63,774 casualties each.\nPedestrians - Pedestrians should also avoid Fridays, with 17,337 casualties since the start of 2013.\n\n\n\nCode - Create Seaborn charts for crash casualties based on day of the week.\ncol_ct = 1\nfig, axes = plt.subplots(\n    4, col_ct, figsize=(15, 40), layout=\"constrained\", gridspec_kw=gridspec_kw\n)\n\nfig.suptitle(\n    \"Total Day of Week Crash Casualties from {0} to {1} by Category\".format(\n        start_date, end_date\n    ),\n    fontsize=title_fontsize,\n)\nfig.supxlabel(\"Day of Week\", fontsize=label_fontsize)\nfig.supylabel(\"Counts\", fontsize=label_fontsize)\n\n# crash.set_index('MONTH_NAME').loc[month_abbr_order].groupby(by=['MONTH_NAME']).agg({'PEDESTRIAN_CASUALTY_COUNT': 'sum'}).plot(kind='bar')\ncrash_casualty_data = create_grouped_casualty_data_by_category(\n    victim_categories, \"day_name\", day_abbr_order\n)\ncrash_casualty_data\ncreate_bar_plots_for_casualty_data(sns, axes, day_abbr_order, crash_casualty_data)\n\n\n\n\n\n\n\nWhat hour of the day should make you stay away?\nThe hour between 5 and 6 pm is the worst time for human casualties, with 40,777 injuries and deaths. The rush-hour times around 5 pm have a high casualty count. The morning rush hour also trends higher, but much lower than the evening rush-hour.\nThe early hours of the morning between 12 and 1 am also having a high body count. This is at a time when you would expect the traffic volume to be low.\n\nCyclists - Follow the trend with 4,167 casualties between 5 and 6 pm.\nMotorists - Get off to an earlier start, with 28,142 casualties between 4 and 5 pm.\nPedestrians - Pedestrians get hit at higher rates between 5 and 6 pm, with 8,6623 casualties since the start of 2013.\n\n\n\nCode - Create Seaborn charts for crash casualties based on the Hour of day.\n#  Create the outer figure box\ncol_ct = 1\nfig, axes = plt.subplots(\n    4, col_ct, figsize=(15, 40), layout=\"constrained\", gridspec_kw=gridspec_kw\n)\n\nfig.suptitle(\n    \"Total Hour of Day Crash Casualties from {0} to {1} by Category\".format(\n        start_date, end_date\n    ),\n    fontsize=title_fontsize,\n)\nfig.supxlabel(\"Hour of Day\", fontsize=label_fontsize)\nfig.supylabel(\"Counts\", fontsize=label_fontsize)\n\ncrash_casualty_data = create_grouped_casualty_data_by_category(\n    victim_categories, \"hour\", hour_order\n)\n\n#  Create the inner charts\ncreate_bar_plots_for_casualty_data(sns, axes, hour_order, crash_casualty_data)"
  }
]